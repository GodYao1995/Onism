[toc]

### Redis基础部分

#### 为什么使用Redis(缓存)？

应对热点数据, 降低数据库压力, 降低响应时间, 提高系统性能. 并且Redis提供了丰富的数据类型以及高级功能. [发布订阅、管道、Lua脚本]. 但是使用了缓存可能出现: 缓存与数据库不一致情况、缓存雪崩、穿透、击穿等. 

#### Redis和Memcached的区别？

Redis是基于内存的k-v数据库, 网络模型采用的是单线程非阻塞IO异步事件处理. 支持多种丰富的数据结构, 比如List的列表, 应用在用户消息、评论、分页, zset应用排行榜等. 支持久化机制. 支持高可用集群部署. [采用单线程原因在于CPU不是瓶颈, 而网络IO才是, 高版本的Redis也采用了多线程的模式来处理网络协议的读取与解析, 但是核心的执行还是单线程(降低并发问题)]. 

Memcached采用的是单进程多线程模式, 可以有效利用多核心.  只提供基本的k-v缓存功能, 可设置过期时间, 容量满即会清除. key最长250个字符, value最大1MB. 

#### Redis基本数据结构？以及他们的适用场景？

String、Hash、List、Set、Zset五种最基本的数据类型. String最简单的类型, 可以做简单的字符串数据缓存、计数器等. Hash可以缓存结构化对象. List一般用作列表型数据, 比如文章列表, 而且非常方便于分页[lrange]并且性能很高, 也可以做消息队列使用. Set无序集合, 去重的特和集合操作如, 并集、交集、差集, 可以用来做粉丝列表、共同好友等. Zset有序集合, 通过key的权重[score分数]进行排序, 多用于排行榜等. 

#### Redis的过期策略以及内存淘汰机制？

Redis是支持过期的内存缓存系统, 过期的策略是定时删除与惰性删除. 

**定期删除**: 默认是每隔 100ms 就**随机抽取**一些设置了过期时间的 key, 检查其是否过期, 如果过期就删除

**惰性删除**: 不主动删除, 当查询Key的时候Redis会检测, 如果过期那么删除

采用上面的两种过期策略方式, 对于超大量的key到期了, 但是又没有定期删除(随机的), 或者没有查询(没有走到惰性删除), 那么Redis有**内存淘汰机制**. 

内存淘汰机制大概有如下几种类型

- [ ] noeviction: 当内存限制达到并且客户端尝试执行会让更多内存被使用的命令返回错误 [一般不用]
- [x] allkeys**-**lru: 尝试回收最近最少使用的键(LRU) [最常用]
- [x] allkeys-random: 回收随机的键
- [ ] volatile-lru: 尝试回收最少使用的键但仅限于在过期集合的键
- [ ] volatile-random: 回收随机的键但仅限于在过期集合的键
- [ ] volatile-ttl: 回收在过期集合的键,并且优先回收存活时间较短的键

使用策略规则

- [ ] 如果数据呈现幂律分布, 也就是一部分数据访问频率高, 一部分数据访问频率低, 则使用allkeys-lru
- [ ] 如果数据呈现平等分布, 也就是所有的数据访问频率都相同, 则使用allkeys-random

#### Redis持久化机制？

持久化目的是备份、容灾, 提高可用性, 属于高可用范畴. 同时通过恢复, 避免宕机带来的流量打到数据库上.

Redis持久化的机制: RDB、AOF、混合持久化

**RDB称为快照持久化**: 对数据进行周期性持久化, 采用的是二进制+数据压缩的方式存储文件到磁盘. Redis使用系统的多进程的COW机制, 也就是copy on write来实现RDB: 首先Fork子进程, 其共享父进程资源不会占用太多的资源, 父进程继续接受客户端请求执行命令修改数据段[操作系统的页面组成], 此时利用COW机制,快照一份页面给父进程进程操作数据, 子进程遍历读取页面持久化到磁盘, 然后循环这种操作[15分钟、5分钟、10000次改变, 可以配置]

RDB优点: 快照形式生成多个RDB文件, 每个文件代表某个时刻, 所以可以做冷备份. Fork子进程的形式性能很好, 并且恢复速度比AOF快 [适用业务对数据丢失不敏感场景]

缺点在于: 快照文件周期生成, 导致这个时间如果宕机, 容易数据丢失; 如果生成的数据文件很大，Fork子进程去做快照可能导致服务短时间不可用. 

**AOF增量日志持久化机制**: 将写命令追加的[append-only]形式写入文件. 存储的是服务器的顺序修改指令, 重启恢复的时候重放AOF文件即可. [适用业务对数据完整性要求的场景]

其策略有: 1. always, 每修改同步 2. 每秒fsync同步, 最大丢失一秒数据 [通常采用]. 

AOF优点在于可以最大程度的恢复数据. 写日志文件的性能是极高的

AOF问题在于记录修改指令, 文件的体积会越来越大, 可以采用了AOF Rewrite来优化, 对同一key只记录最后修改的值. 重放AOF恢复数据也是较RDB慢的.

**RDB-AOF混合持久化**

AOF Rewirte时, 先进行RDB快照写到AOF日志文件, 期间以及后续的写命令追加到AOF文件中. 

#### Redis分布式锁有了解么, 用在什么场景?

分布式锁用于限制分布式系统中访问共享资源. [不同的系统例如数据库的锁就无法使用了]

Redis的分布式锁,实际上就是利用setnx命令, set if not exist, 当key不存在时才能设置. 

setnx local_key v 加锁, del lock_key即是释放锁.  注意: 如果出现宕机, 没有删除key, 造成其他服务无法获取到锁, 可以在key上加过期时间 set k v ex 100 nx

#### Redis执行Lua脚本有接触么, 用在什么场景?

Redis可以执行Lua脚本, Lua脚本的执行是原子性的, 可以用来做CAS, 例如修改库存等.

#### Redis管道(Pipline)是什么, 有什么作用?

Redis执行命令是单调的: 发送命令, 排队, 执行, 返回. 管道是将多个命令发送到服务器, 而不用等待回复, 最后在一个步骤中读取该答复. 将多个命令的RTT, 缩短为一个RTT. [客户端支持发送多个命令, 并且可以改变读写顺序, 服务端支持pipline协议]

#### Redis能做延迟队列吗, 如何实现?

通过Redis的Zset结构、以及zrangebyscore、zadd、zrem命令实现延迟队列

将消息序列化为字符串作为value, 消息的过期处理时间 + 当前时间 作为 score, zadd存放到Zset中

消费: 通过zrangebyscore指令轮询获取最小的score, 如果task.time >= now, 即是达到任务处理时间, 发布到准备队列, 然后以value从Zset中删除. [必须判断删除成功,当前的value才可以被消费]

#### Redis发布订阅模式有了解吗?

#### Redis的事务了解么?

Redis事务一次执行多个命令, exec执行前将命令**放入队列缓存**. 事务是批量指令并非原子化操作, 中间某条指令的失败不会导致前面已做指令的回滚, 而且后续命令会继续执行. [可以watch一个key,强制原子化命令队列, 如果监听到的key发生改变, 那么事务队列不会执行]

Redis事务命令有: MULTI 、EXEC、DISCARD、WATCH

#### Redis如何实现CAS? 事务、Lua脚本

CAS用来解决高并发情况下, 丢失更新的问题, 也就是写偏序. [GET, IF, SET] 等多个过程. [关系型数据库乐观模式也可以使用CAS]

1. watch key, 一旦key被修改则事务回滚. 事务中的命令会进入队列, 最后靠exec执行.
2. Lua脚本亦可进行compare and set的操作