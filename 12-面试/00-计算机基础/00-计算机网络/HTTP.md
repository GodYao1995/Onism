[TOC]

### HTTP

#### HTTP协议

超文本传输协议; 基于TCP, 以请求-响应机制, 定义客户端和服务端的数据[图片、文本、视频、音频]交换方式.

#### HTTP1.1新特性

1.  持久连接: 一次TCP连接, 可以发送多次HTTP请求[Keep-Alive: Connection ]

2.  管线化: 可以不必等待响应的返回, 同时发出多个请求
3.  断点续传 Range
4.  缓存控制策略: E-tag, If-Unmodified-Since, If-Match, If-None-Match等缓存控制标头控制缓存失效

#### 报文格式

请求报文
1. 请求行：请求方法、请求URL、HTTP版本
2. 请求首部
3. 请求体

~~~
GET /hello HTTP/1.1 \r\n
Host: 10.211.55.18:8080 \r\n
Connection: keep-alive\r\n
~~~

响应报文
1. 响应行：HTTP版本、响应状态码、响应短语
2. 响应首部
3. 响应体

~~~
HTTP/1.1 200 OK\r\n
Date: Tue, 28 Feb 2023 14:13:38 GMT\r\n
Content-Length: 12\r\n
Content-Type: text/plain; charset=utf-8\r\n
~~~

#### 状态码

| 状态码 |               意义                |
| :----: | :-------------------------------: |
|  200   |           OK, 请求成功            |
|  201   |           OK, 新建资源            |
|  202   |        请求被接受, 未处理         |
|  204   |          OK, 无内容返回           |
|  301   |  重定向, 请求资源被指派固定的URL  |
|  302   | 重定向, 请求资源临时位于另外的URL |
|  304   |         文档没有修改(GET)         |
|  400   |             错误请求              |
|  401   |             未被授权              |
|  403   |   不明原因禁止, 通常无权限访问    |
|  404   |             没有找到              |
|  500   |          内部服务器错误           |
|  501   |             没有实现              |
|  502   |             网关错误              |
|  503   |          服务器暂时失效           |

301和302有什么区别？

301 永久重定向, 比如域名跳转

301 Moved Permanently 被请求的资源已永久移动到新位置, 并且将来任何对此资源的引用都应该使用本响应返回的若干个URI之一. **如果可能, 拥有链接编辑功能的客户端【浏览器】应当自动把请求的地址修改为从服务器反馈回来的地址. 除非额外指定, 否则这个响应也是可缓存的**

302 临时重定向, 比如从未登录的页面跳到登录页面

302 Found 请求的资源现在临时从不同的URI响应请求.由于这样的重定向是临时的, 客户端应当继续向原有地址发送以后的请求. 只有在Cache-Control或Expires中进行了指定的情况下, 这个响应才是可缓存的

#### 请求方法

| 请求方法 |          意义          |
| :------: | :--------------------: |
|   GET    |        请求资源        |
|   POST   |        传输数据        |
|   PUT    |        上传文件        |
|   HEAD   |      获取报文首部      |
|  DELETE  |        删除文件        |
| OPTIONS  | 查询当前请求允许的方法 |

GET POST区别？

1.  意义上看, GET获取资源, POST倾向于Push发送(新建资源)
2.  GET请求的URL有长度限制, 发送数据在URL后面
3.  POST发送数据在请求体中
4.  GET请求, 一个TCP包
5.  POST请求两个, 先发送header 100 continue , 然后发送data  200 OK
6.  GET请求会被cache, POST不会
7.  GET请求浏览器可以回退前进, POST会重新提交表单

#### 无状态协议

HTTP是一种无状态的协议, 不会保存上一次客户端的请求状态

#### 持续连接

HTTP1.0, 默认使用非持久连接, 每发起一次HTTP请求响应后就断开TCP连接

HTTP1.1, 默认使用持续连接, 一次TCP连接中, 可以发起多次HTTP请求, 不会立马断开TCP, 有一个保持时间

~~~
Connection:keep-alive
~~~

#### Cookie

由于HTTP1.1的无状态性, Cookie被用来跟踪用户. Cookie由服务器设置到响应头, 并由浏览器管理(同一域名下);

浏览器关闭消失;

响应头

~~~
Set-Cookie: name=mike;
~~~

每次请求该域名下都会携带Cookie

~~~
Cookie: name=mike;
~~~

#### URI、URL

1.  URI  统一资源标识符, 用来唯一标示一个资源 [图片、文档、视频、音频]
2.  URL 统一资源定位符, 一种具体的URI, 可以标示, 也可以定位到具体的资源
    *   协议
    *   主机
    *   主机资源的具体地址

#### 浏览器输入URL到服务器返回的流程

**过程**

1.  DNS解析
2.  TCP链接
3.  发送HTTP请求
4.  服务器处理请求并且返回HTTP报文
5.  浏览器解析数据渲染页面
6.  链接结束

#### HTTP2

1.  采用全二进制协议, 所有的数据都是二进制的
2.  管线化, 多路复用: 同时可以发出多个HTTP请求, 并且请求与响应可以交错
3.  不再以文本的方式传输, **二进制分帧层**, 对头部进行了压缩, 支持流的控制
4.  服务器可以主动推送

#### HTTPS

》超文本安全传输协议, 通过TCP建立连接、HTTP进行通信, 利用SSL/TLS进行加密

TLS/SSL

》传输层安全协议/安全套接字层 是一种数据传输安全协议

SSL包含记录层和传输层, 记录层协议确定传输层的数据封装格式. 传输层安全协议采用x.509认证, 之后采用非对称加密来做身份认证, 进而交换对称密钥作为数据加解密. 

TLS/SSL是协议标准, x.509是协议实现

加密方式

对称加密

- [ ] 加密、解密使用同一套密钥
- [ ] 运算速度快, 方式简单 
- [ ] 密钥采用的是明文传输, 密钥容易被劫获
- [ ] AES、DES、3DES等

非对称加密

- [ ] 加密、解密使用不同的密钥
- [ ] 公钥加密的数据只能通过私钥来解密,私钥加密的数据只能通过公钥解密
- [ ] 更加的安全, 但是加密的效率低
- [ ] RSA等

#### HTTPS 连接

1.  TCP的三次握手建立链接
2.  客户端通过发送Client Hello报文开始SSL通信, 报文中包含
    * 客户端支持的SSL的版本
    * 加密组件列表(对称加密算法、非对称加密、Hash)
    * 随机数 ClientRandom
3.  服务器可进行SSL通信时, 会以Server Hello报文作为应答, 和客户端一样, 在报文中包含
    * SSL版本以及加密组件, 服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的
    * 随机数 ServerRandom
4.  之后服务器发送Certificate报文, 报文中包含公开密钥证书
5.  最后服务器发送Server Hello Done 报文通知客户端, 最初阶段的SSL握手协商部分结束
6.  客户端验证数字证书有效性(有效期、域名、颁发机构)
7.  SSL第一次握手结束之后, 客户端以Client Key Exchange报文作为回应, 报文中包含通信加密中使用的一种被称为Pre-master secret的随机密码串, 该报文已用步骤4中的公开密钥进行加密
8.  接着客户端继续发送Change Cipher Spec报文, 该报文会提示服务器, 在此报文之后的通信会采用Pre-master secret密钥加密
9.  客户端发送Finished报文, 该报文包含连接至今全部报文的整体校验值, 这次握手协商是否能够成功, 要以服务器是否能够正确解密该报文作为判定标准
10.  服务器同样发送Change Cipher Spec报文
11.  服务器同样发送Finshed报文
12.  服务器和客户端的Finished报文交换完毕之后, SSL连接就算建立完成, 当然, 通信会受到SSL的保护, 从此处开始进行应用层协议的通信, 即发送HTTP请求

![HTTPS](./images/HTTPS.svg)