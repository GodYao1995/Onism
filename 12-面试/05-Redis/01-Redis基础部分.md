[toc]

### Redis基础部分

#### 为什么使用Redis(缓存)？

应对热点数据, 降低数据库压力, 降低响应时间, 提高系统性能. 并且Redis提供了丰富的数据类型以及高级功能. [发布订阅、管道、Lua脚本]. 但是使用了缓存可能出现: 缓存与数据库不一致情况、缓存雪崩、穿透、击穿等. 

#### Redis和Memcached的区别？

Redis是基于内存的k-v数据库, 网络模型采用的是单线程非阻塞IO异步事件处理. 支持多种丰富的数据结构, 比如List的列表, 应用在用户消息、评论、分页, zset应用排行榜等. 支持久化机制. 支持高可用集群部署. [采用单线程原因在于CPU不是瓶颈, 而网络IO才是, 高版本的Redis也采用了多线程的模式来处理网络协议的读取与解析, 但是核心的执行还是单线程(降低并发问题)]. 

Memcached采用的是单进程多线程模式, 可以有效利用多核心.  只提供基本的k-v缓存功能, 可设置过期时间, 容量满即会清除. key最长250个字符, value最大1MB. 

#### Redis基本数据结构？以及他们的适用场景？

String、Hash、List、Set、Zset五种最基本的数据类型. String最简单的类型, 可以做简单的字符串数据缓存、计数器等. Hash可以缓存结构化对象. List一般用作列表型数据, 比如文章列表, 而且非常方便于分页[lrange]并且性能很高, 也可以做消息队列使用. Set无序集合, 去重的特和集合操作如, 并集、交集、差集, 可以用来做粉丝列表、共同好友等. Zset有序集合, 通过key的权重[score分数]进行排序, 多用于排行榜等. 

#### Redis的过期策略以及内存淘汰机制？

Redis是支持过期的内存缓存系统, 过期的策略是定时删除与惰性删除. 

**定期删除**: 默认是每隔 100ms 就**随机抽取**一些设置了过期时间的 key, 检查其是否过期, 如果过期就删除

**惰性删除**: 不主动删除, 当查询Key的时候Redis会检测, 如果过期那么删除

采用上面的两种过期策略方式, 对于超大量的key到期了, 但是又没有定期删除(随机的), 或者没有查询(没有走到惰性删除), 那么Redis有**内存淘汰机制**. 

内存淘汰机制大概有如下几种类型

- [ ] noeviction: 当内存限制达到并且客户端尝试执行会让更多内存被使用的命令返回错误 [一般不用]
- [x] allkeys**-**lru: 尝试回收最近最少使用的键(LRU) [最常用]
- [x] allkeys-random: 回收随机的键
- [ ] volatile-lru: 尝试回收最少使用的键但仅限于在过期集合的键
- [ ] volatile-random: 回收随机的键但仅限于在过期集合的键
- [ ] volatile-ttl: 回收在过期集合的键,并且优先回收存活时间较短的键

使用策略规则

- [ ] 如果数据呈现幂律分布, 也就是一部分数据访问频率高, 一部分数据访问频率低, 则使用allkeys-lru
- [ ] 如果数据呈现平等分布, 也就是所有的数据访问频率都相同, 则使用allkeys-random

#### Redis持久化机制？

持久化目的是备份、容灾, 提高可用性, 属于高可用范畴. 同时通过恢复, 避免宕机带来的流量打到数据库上.

Redis持久化的机制: RDB、AOF、混合持久化

**RDB称为快照持久化**: 对数据进行周期性持久化, 采用的是二进制+数据压缩的方式存储文件到磁盘. Redis使用系统的多进程的COW机制, 也就是copy on write来实现RDB: 首先Fork子进程, 其共享父进程资源不会占用太多的资源, 父进程继续接受客户端请求执行命令修改数据段[操作系统的页面组成], 此时利用COW机制,快照一份页面给父进程进程操作数据, 子进程遍历读取页面持久化到磁盘, 然后循环这种操作[15分钟、5分钟、10000次改变, 可以配置]

RDB优点: 快照形式生成多个RDB文件, 每个文件代表某个时刻, 所以可以做冷备份. Fork子进程的形式性能很好, 并且恢复速度比AOF快 [适用业务对数据丢失不敏感场景]

缺点在于: 快照文件周期生成, 导致这个时间如果宕机, 容易数据丢失; 如果生成的数据文件很大，Fork子进程去做快照可能导致服务短时间不可用. 

**AOF增量日志持久化机制**: 将写命令追加的[append-only]形式写入文件. 存储的是服务器的顺序修改指令, 重启恢复的时候重放AOF文件即可. [适用业务对数据完整性要求的场景]

其策略有: 1. always, 每修改同步 2. 每秒fsync同步, 最大丢失一秒数据 [通常采用]. 

AOF优点在于可以最大程度的恢复数据. 写日志文件的性能是极高的

AOF问题在于记录修改指令, 文件的体积会越来越大, 可以采用了AOF Rewrite来优化, 对同一key只记录最后修改的值. 重放AOF恢复数据也是较RDB慢的.

**RDB-AOF混合持久化**

AOF Rewirte时, 先进行RDB快照写到AOF日志文件, 期间以及后续的写命令追加到AOF文件中. 

#### Redis分布式锁有了解么, 用在什么场景?

分布式锁用于限制分布式系统中访问共享资源. [限制并发进程破坏系统状态]

实际上如果应用层多实例部署, 但是数据库层是唯一的话, 可以采用数据库锁来实现分布式锁. 但是事务中锁排队无法取消, 并且会大大降低系统的吞吐量.

Redis的分布式锁[单点方案]: 

方案1: setnx命令, set if not exist, 当key不存在时才能设置. setnx local_key client_value 加锁.  如果出现宕机, 没有删除key, 造成其他服务无法获取到锁, 可以在key上加过期时间 expire lock_key expire_time.  del lock_key即是释放锁

方案2: set命令扩展参数set lock_key client_value ex expire_time nx . 由于setnx 与 expire 不是原子的,  所以通常使用set命令保证原子性.  释放锁采用Lua脚本, 检测是否是当前客户端加的锁. 

~~~lua
if redis.call("get",KEYS[1]) == ARGV[1] then
    return redis.call("del",KEYS[1])
else
    return 0
end
~~~

看似已经解决了大部分的问题, 实际上还有以下问题需要注意: 

1. 如果A请求执行业务超过了expire_time时间, 导致B请求获取到了锁执行业务, 此时A系统执行完成, 删除了lock_key[此时可采用上述的Lua脚本判断是否是当前的请求事物的锁], C请求就能获取锁, 此时B, C 请求就出现了并发问题. 所以设置一个较为合理的expire_time时间是重要的[可以参考接口的响应时间].  
2. 单点的方案可以用哨兵模式解决高可用的问题, 但是发送主从切换, 如果数据没有同步, 就造成锁丢失. 如果需要追求高性能单节点的Redis锁即可, 但是正确性无法完全保证.  

Redis的分布式锁[集群方案], RedLock.  假设五个master节点: A, B, C, D, E[不包含从节点] 组成了Redis集群. 加锁步骤如下:

1. 获取当前服务器Unix毫秒时间
2. 轮流用相同的key和随机值在N个节点上请求锁. 在这一步里, 客户端在每个master上请求锁时, 会有一个和**总的锁释放时间**相比小的多的**超时时间**. 比如如果锁自动释放时间是10秒钟, 那每个节点锁请求的超时时间可能是5-50毫秒的范围, 这个可以防止一个客户端在某个宕掉的master节点上阻塞过长时间, 如果一个master节点不可用了, 我们应该尽快尝试下一个master节点. 
3. 客户端计算第二步中获取锁所花的时间T2, 只有当客户端在大多数master节点上成功获取了锁, 而且总共消耗的时间不超过锁释放时间, 这个锁就认为是获取成功了. 
4. 如果锁获取成功了, 那现在锁自动释放时间就是最初的锁释放时间减去之前获取锁所消耗的时间. 
5. 如果锁获取失败了, 不管是因为获取成功的锁不超过一半(N/2+1), 还是因为总消耗时间超过了锁释放时间, 客户端都会到每个master节点上释放锁, 即便是那些他认为没有获取成功的锁. 

#### Redis执行Lua脚本有接触么, 用在什么场景?

Redis可以执行Lua脚本, Lua脚本的执行是原子性的, 可以用来做CAS, 例如修改库存等.

#### Redis管道(Pipline)是什么, 有什么作用?

Redis执行命令是单调的: 发送命令, 排队, 执行, 返回. 管道是将多个命令发送到服务器, 而不用等待回复, 最后在一个步骤中读取该答复. 将多个命令的RTT, 缩短为一个RTT. [客户端支持发送多个命令, 并且可以改变读写顺序, 服务端支持pipline协议]

#### Redis能做延迟队列吗, 如何实现?

通过Redis的Zset结构、以及zrangebyscore、zadd、zrem命令实现延迟队列

将消息序列化为字符串作为value, 消息的过期处理时间 + 当前时间 作为 score, zadd存放到Zset中

消费: 通过zrangebyscore指令轮询获取最小的score, 如果task.time >= now, 即是达到任务处理时间, 发布到准备队列, 然后以value从Zset中删除. [必须判断删除成功,当前的value才可以被消费]

#### Redis发布订阅模式有了解吗?

1.  发布订阅模式实际上是生产者消费者模型
2.  支持消息多播，中间件负责将消息复制到多个消息队列，每个消息队列由相应的消费组进行消费
3.  支持单个频道和多个频道发布订阅
4.  但是Redis的发布订阅模式不是可靠的，当消费者下线，消息就会丢失，并且宕机后消息无法持久化

#### Redis的事务了解么?

Redis事务一次执行多个命令, exec执行前将命令**放入队列缓存**. 事务是批量指令并非原子化操作, 中间某条指令的失败不会导致前面已做指令的回滚, 而且后续命令会继续执行. [可以watch一个key,强制原子化命令队列, 如果监听到的key发生改变, 那么事务队列不会执行]

Redis事务命令有: MULTI 、EXEC、DISCARD、WATCH

#### Redis如何实现CAS? 事务、Lua脚本

CAS用来解决高并发情况下, 丢失更新的问题, 也就是写偏序. [GET, IF, SET] 等多个过程. [关系型数据库乐观模式也可以使用CAS]

1. watch key, 一旦key被修改则事务回滚. 事务中的命令会进入队列, 最后靠exec执行.
2. Lua脚本亦可进行compare and set的操作