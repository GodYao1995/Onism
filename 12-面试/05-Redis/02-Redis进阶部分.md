[TOC]

## Redis面试进阶部分



#### 问题 1：Redis分布式锁？

1.  分布式锁主要是在程序并发执行的时候保证操作的原子性，也就是当前执行的线程不会被线程调度机制打断
2.  Redis的分布式锁,实际上就是setnx命令，set if not exist
    *   当key不存在时设置，所以存在key就不能设置
    *   多一个客户端来操作被该Key时，会排斥其他的同时来操作的客户端，相当于加了一把锁
3.  必须等待当前的客户端结束或者过期时间到，释放锁，后面的客户端才可以操作Key
4.  注意：为了避免阻塞住需要加上锁过期时间，setnx命令可以加过期时间



#### 问题 2：在海量Key中如何找出某些固定开头的Key？

1.  可以使用 keys 命令，支持pattter模式，
2.  但是由于Redis单线程处理机制，数据量太大的话会导致线程阻塞，影响服务的提供，所以不是推荐使用keys
3.  推荐使用 scan 命令，他可以无阻塞的提取指定模式的Key列表，但是有一定几率重复Key，不过可以手动去重



#### 问题 3：Redis如何实现异步消息队列？

1.  通过Redis的List结构，以及rpush、lpop命令可以是实现异步队列，
2.  当里面没有数据的时候,lpop无法获取到数据,lpop空轮询造成客户端CPU压力增大和Redis的QPS升高,所以需要sleep
3.  sleep增加了延迟，鉴于此 blpop 命令可以阻塞读，在队列没有数据的时候，会立即进入休眠状态，一旦数据到来，则立刻醒过来，降低延迟

**注意** 

1.  如果长时间没有数据，那么服务器就会断开连接，blpop会抛出异常，所以程序中需要捕获异常如果需要可以重试
2.  Redis实现的异步消息队列不是完全可靠消息队列，可以使用专业MQ解决
3.  异步消息队列不支持多播【发布订阅模式支持】



#### 问题 4：延时队列？

1.  通过Redis的Zset结构、以及zrangebyscore、zadd、zrem命令实现延迟队列

2.  将消息序列化为字符串作为value，消息的过期处理时间作为score，zadd存放到Zset中

3.  消费
    *   有可能是多个线程消费者，所以需要注意并发争抢消息
    *   通过zrangebyscore指令获取N秒之前的数据轮询进行处理，然后以value从Zset中删除
    *   必须判断删除成功，当前的value才可以被消费
    
4.  **延时队列**？

    *   sortedset——>时间戳score——>消息内容作为key

    *   ——>调用zadd来生产消息——>消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理



#### 问题 5：了解Pipline吗？

1.  Pipline管道技术实际上是客户端提供的，目的是将多个Redis命令多次的网络IO缩减为1次
2.  原理是客户端通过对管道中的指令列表改变读写顺序，以此来减少IO



#### 问题 6：发布订阅模式Pub/Sub?

1.  发布订阅模式实际上是生产者消费者模型
2.  支持消息多播，中间件负责将消息复制到多个消息队列，每个消息队列由相应的消费组进行消费
3.  支持单个频道和多个频道发布订阅
4.  但是Redis的发布订阅模式不是可靠的，当消费者下线，消息就会丢失，并且宕机后消息无法持久化



#### 问题 7：Redis的过期策略以及内存淘汰机制？

该问题主要针对：1. 过期后的key不会立即回收内存 2. 内存占用满了

过期策略对持久化没有影响，会在RDB持久化和AOF追加的时候判断key是否过期

1.  Redis的过期策略

    *   定期删除: 默认是每隔 100ms 就**随机抽取**一些设置了过期时间的 key，检查其是否过期，如果过期就删除
    *   惰性删除: 不主动删除，当查询Key的时候Redis会检测，如果过期那么删除

    Redis采用上面的两种过期方式，但是如果随机抽取漏了，或者你没有去查询，那么只能靠内存淘汰机制

2.  内存淘汰机制

     FIFO 淘汰最早数据、LRU剔除最近最少使用、和 LFU 剔除最近使用频率最低的数据几种策略

    |      机制       |                             说明                             |
    | :-------------: | :----------------------------------------------------------: |
    |   noeviction    | 当内存限制达到并且客户端尝试执行会让更多内存被使用的命令返回错误 |
    | allkeys**-**lru |   尝试回收最少使用的键（LRU），使得新添加的数据有空间存放    |
    |  volatile-lru   | 尝试回收最少使用的键（LRU）但仅限于在过期集合的键使得新添加的数据有空间存 |
    | allkeys-random  |            回收随机的键使得新添加的数据有空间存放            |
    | volatile-random | 回收随机的键使得新添加的数据有空间存放, 但仅限于在过期集合的键 |
    |  volatile-ttl   | 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放 |


3.  使用策略规则

    *   如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用allkeys-lru
    *   如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用allkeys-random

    

#### 问题 8：持久化机制？

1.  Redis有两种持久化的机制RDB和AOF

2.  RDB称为快照持久化，对数据进行周期性持久化，存放的是**二进制文件**

    *   原理

        *   Redis使用系统的多进程的COW机制，也就是Copy on Write来实现RDB
        *   首先Fork子进程，其共享父进程资源不会占用太多的资源
        *   父进程继续接受客户端请求执行命令修改数据段【操作系统的页面组成】，此时利用COW机制，快照一份页面给父进程进程操作数据，子进程遍历读取页面持久化到磁盘，
        *   然后循环这种操作【15分钟、5分钟、10000次改变】【可以配置】

    *   优点

        *   优点生成多个RDB文件，每个文件代表某个时刻，所以可以做冷备份
        *   Fork子进程的形式性能很好，并且恢复速度比AOF快

    *   缺点

        *   快照文件周期生成，导致这个时间如果宕机，容易数据丢失【如果时间很长那么完蛋】

        *   如果生成的数据文件很大，Fork子进程去做备份可能导致服务短时间不可用

            

3.  AOF增量日志

    *   原理

        *   存储的是服务器的顺序修改指令，追加的形式写入文件，日志会越来越大【有重写功能】
        *   为了避免宕机情况下日志丢失，系统提供fsync函数可以强制将指令刷新到磁盘
    *   策略
        *   always，每修改同步不丢失数据
        *   每秒，最大丢失一秒数据
        *   不追加，不可控
    *   缺点
    *   相同规模数据集AOF大于RDB, 并且效率慢于RDB
      *   fsync函数是IO操作，这样会降低Redis性能

    

4.  **混合持久化**
  
    *   RDB 文件的内容和增量的 AOF 日志文件存在一起
    *   AOF 日志不再是全量的日志, 而是自持久化开始到持久化结束的这段时间发生的增量 AOF 日志
    *   在 Redis 重启的时候, 可以先加载 rdb文件 的内容, 然后再重放增量 AOF 日志【提高效率】



#### 问题 9：Redis常见性能问题和解决方案？

1.  Master不要做持久化的工作，如果数据比较重要Slave开启AOF每秒同步
2.  最好在同一个局域网内
3.  主从复制采用链表的形式 master——>slave——>slave
4.  避免在压力很大的主库上增加从库



#### 问题10：多个系统对同Redis同一Key操作？

1.  会造成数据的错误【假设你需要的顺序的A B C三个系统操作】
2.  使用分布式锁ZooKeeper，每个系统必须获取锁才能去操作，并且同时一刻只能有一个系统获取到锁



#### 问题12：Redis和Memchache抉择？