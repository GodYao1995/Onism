[TOC]

### Redis面试进阶部分

#### 问题 0：Redis为什么这么快？

1.  前提
    *   Redis单点吞吐量单点TPS达到8万/秒, QPS达到10万/秒
    *   QPS: 应用系统每秒钟最大能接受的用户访问
    *   TPS：每秒钟最大能处理的请求数

2.  原因

    *   Redis是C语言编写的缓存数据库, 完全基于内存操作的
    *   Redis的数据结构简单, 没有传统型数据库各种锁机制以及完备的事务支持
    *   Redis采用单线程IO多路复用技术【单线程指的是指令执行工作线程】
        *   单线程不用考虑加锁解锁
        *   不用考虑线程上下文切换【简单理解就是保存当前线程的工作现场】
    *   高效的非阻塞IO多路复用技术【多路指的是多个网络请求、复用指的是一个服务线程】
        *   epoll函数可以同时监听多个文件描述符的读写状态【底层数据结构是红黑树+链表】
        *   当数据可读可写的时候发起通知机制执行, 不在系统IO上浪费时间

3.  服务器都是多核心？单线程是不是浪费？

    *   可以在单机上面开启多个Redis实例

    

#### 问题 1：Redis线程模型？

1.  首先Redis在6.0版本之前是单线程模型
    *   其实也不准确, 只能说执行命令是单线程
    *   部分的任务是其他线程执行【内存淘汰、持久化等】
2.  为什么一开始是单线程？
    *   Redis是完全基于内存操作【除非涉及持久化否则没有系统的IO】
    *   IO多路复用机制可以同时监听多个文件描述符的读写状态, 具有了多线程的特点
    *   单线程不用处理某些命令的并发读写问题, 不用考虑锁
    *   总之单机Redis可以并发10W, 已经足够快了, 再不行集群搞起来
3.  多线程？
    *   缓存的瓶颈在于内存和网络IO
    *   在6.0后Redis 【master-sorker模型】
        *   多线程worker只是用来处理网络数据的读写和协议解析
        *   处理完以后将主动权交还给主线程
        *   部分耗时的命令多线程处理比如del命令



#### 问题 2：主从同步？

1.  Redis可以进行主从同步以及从从同步, 缓解主库的压力, **一般master写, slave读**

2.  CAP理论一致性和可用性两难全, 但是从库会努力追赶主库达到最终一致性

3.  主从同步是异步进行的，所以不影响master的操作

4.  流程
    *   当从节点第一次加入时, 主节点做一次bgsave, 也就是快照, 同时将后续修改操作记录到内存buffer
    *   将快照的文件传送到从节点, 从节点清空内存数据, 立即执行全量加载, 然后通知主节点进行后续增量同步
    *   后续的增量数据通过AOF日志同步即可

5.  缺点
    *   环形buffer大小配置, 但是有限的, 可能会覆盖前面的指令, 所以需要配置大小合适的buffer
    *   所以主从的形式并不能保证数据不丢失

    

#### 问题 5：Redis主从模式 + 哨兵？

主从模式提高了系统的能力，但是一旦mster宕机，系统将不能对外服务，可以利用哨兵机制【特殊的Redis实例】

-   作用

    *   监控节点状态
    *   当Master节点故障时，自动提升Replication（Slave）为Master
    *   发送故障通知
    *   配置传播（就是把更新后的集群配置传播给其他哨兵进行更新，保持一致性）

-   方式

    -   采用3或者5个Redis实例作为哨兵，形成高可用的模式
    -   哨兵负责持续监控从节点的健康, 当主节点挂掉时【Raft选举算法】
        *   从哨兵中选取一个leader，然后该leader选择一个最优的slave切换为master
        *   修改其他slave的配置，指向新的master

-   使用哨兵模式

    *   客户端来连接系统,会首先连接 sentinel来查询主节点的地址

    然后再去连接主节点进行数据交互

-   缺点：无法保证数据不丢失, 因为主从数据同步采用的是异步的形式, 主库挂掉但是数据还没同步过去



#### 问题 3：Redis集群？

1.  Redis集群重在对Redis进行扩展，将Redis的数据按照一定规则分配到多台服务器【海量数据+高并发+高可用】
2.  节点连成去中心化方式集群, 采用特殊的二进制协议交换数据
3.  配置集群至少需要六个节点，三主三从
    *   不同的master不同数据
    *   master和slave数据一致
4.  集群情况下, Key如何寻址？

    *   采用Hash槽的形式用来定位Key所在的Redis实例
    *   默认16384个slots，分布在Redis实例【槽的数目可以更改】
    *   对Key做crc16的Hash算法得到一个整数值, 然后对16384取模得到key具体的槽位
    *   经过 **gossip 协议，周期性的和集群中的其他节点交换信息，最终 整个集群都会知道 key 在哪一个槽上**
5.  缺点
    *   集群下多key无法操作
    *   无法自动迁移



#### 问题 4：集群如何高可用？

1.  主节点可以设置多个从节点, 单主节点故障可以进行选举主从切换
2.  如果某个主节点没有从节点, 如果故障会导致集群不可用, 但是可以设置配置, 允许部分节点故障
3.  **Gossip通信协议**
    *   数据分片【槽】和节点的对应关系
    *   集群中每个节点可用状态
    *   集群结构发生变更时，通过一定的协议对配置信息达成一致
4.  选举主从切换【Redis Cluster 重用了 Sentinel 的代码逻辑】
    *   集群中的每个节点都会定期地向集群中的其他节点发送 PING 消息，以此交换各个节点状态 信息，检测各个节点状态:在线状态、疑似下线状态 PFAIL、已下线状态 FAIL
5.  如果是主节点FAIL【Raft领头选举算法】

    *   首先：其他主节点对FAIL主节点的所有从节点的过滤, 依据是从节点与其主节点断开时间
    *   然后：再依据从节点对主节点的复制数据offset来排序【选出一个适合的从节点】
    *   最后：其他的有投票权的主节点来进行选举, 超过 n/2 + 1通过，该从节点切换为主节点
        *   撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己
        *   对集群进行广播 PONG 消息，告知其他节点已经成为新的主节点
        *   开始接收和处理槽相关的请求
6.  缺点
    *   不支持多数据库，默认0号库【0-16】
    *   key 批量操作支持有限



#### 问题 6：手写LRU算法？

#### 问题 7：Redis内存碎片？

~~~bash
127.0.0.1:6379> info Memory
# Memory
used_memory:1050304       # 使用了多少
used_memory_rss:2920448   # redis 申请了多少
~~~

1.  used_memory_rss / used_memory  碎片率
2.  有多个内存分配器，默认是jemalloc，划分小大中内存块，每个内存块又细化分更多的小内存块
3.  存储数据会选择合适的大小
    *   更新数据会删除数据然后需要重新申请，以前的内存不会马上回收，以后不用每次向系统申请
4.  解决办法
    *   重启
    *   修改内存分配器
    *   Redis4.0支持 自动清理命令 和 手动清理命令

#### 问题8：big key

1.  例如：string长度大于10K，list长度大于10240认为是big bigkeys
2.  以hash类型举例来说，对于field过多的场景，可以根据field进行hash取模，生成一个新的key

~~~
hash_key:{filed1:value, filed2:value, filed3:value ...}，可以hash取模后形成如下key:value形式
hash_key:mod1:{filed1:value}
hash_key:mod2:{filed2:value}
hash_key:mod3:{filed3:value}
~~~

3.  string类型的big key，如文章正文，建议不要存入redis，用文档型数据库MongoDB代替或者直接缓存到CDN上



**拓展**
通常来说找到redis中的big key有如下几种方法

1.  redis-cli自带--bigkeys，例如：redis-cli -h -a --bigkeys
2.  获取生产Redis的rdb文件，通过rdbtools分析rdb生成csv文件，再导入MySQL或其他数据库中进行分析统计，根据size_in_bytes统计bigkey
3.  通过python脚本，迭代scan key，每次scan 1000，对扫描出来的key进行类型判断，例如：string长度大于10K，list长度大于10240认为是big bigkeys
4.  其他第三方工具，例如：redis-rdb-cli
    地址：https://github.com/leonchen83/redis-rdb-cli



#### 问题9：key如何设置

1.  避免bigkey

2.  分级设置key

3.  加上项目前缀

4.  设置过期时间

5.  见明知意 

    