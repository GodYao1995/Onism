[TOC]

### 面试

#### Index: B+树

- [ ] 为什么选择B+树?
- [ ] 索引结构是怎么样的?
- [ ] 聚簇索引
- [ ] 二级索引、唯一索引
- [ ] 覆盖索引

#### SQL:    优化

- [ ] 频繁查询或者分组的字段需要建立索引, 避免全表扫描
- [ ] 命中索引、避免索引失效情况
- [ ] 插入数据时, 可采用批量的形式

1. 避免like前置%, 索引实效
2. 避免in, not int, 连续数值, 可采用between
3. 避免子查询使用in, not in, 可采用exists
4. 避免使用or, 可采用union
5. 避免采用is null值判断, 可设置默认值
6. 联合索引, 注意最左前缀原则
7. order by 要与where条件一致

#### SQL:    执行计划

~~~sql
EXPLAIN SELECT x
~~~

#### 事务: ACID

隔离性

其实不同隔离级别以及幻读、不可重复读、脏读等问题都只是表面现象, 是各种锁在不同加锁时间上组合应用所产生的结果, 以锁为手段来实现隔离性才是数据库表现出不同隔离级别的根本原因.

MVCC(多版本并发控制, Inno DB引擎实现)  读+写场景的可重复读隔离性.  [快照、事务ID]

#### 锁

#### 表结构设计

##### 字段设计

- [ ] 越小越好(预估值的范围)
- [ ] 越简单越好(数字类型比字符串类型代价低)
- [ ] 内建的类型例如日期、IP, 而不是使用字符串
- [ ] 减少NULL
- [ ] 确定大类型后, 也需要区分同类型下的其他, 例如tinyint、int、char、varchar等

##### 分区表

##### 范式

1. 第一范式: 每一列必须是原子的"业务上"不可再分的; 尽可能的分割.
2. 第二范式: 在满足第一范式情况下, 所有记录都是可唯一标识的, 非主键列要完全依赖主键
3. 第三范式: 在满足第二范式情况下, 非主键列不能相互依赖