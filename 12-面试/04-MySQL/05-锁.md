[TOC]

## 锁

> 当数据库有并发事务的时候, 可能导致产生的数据不一致, 这就需要锁机制来保障访问的次序

### 一致性读

MVCC并发版本控制, 一致性非锁定读, 或者称为快照读, 可显著提高并发性能, 不会对记录做加锁的操作, 其他事务可自由修改记录

### 行锁

》行锁是在索引记录上的锁

#### 锁定读

》MVCC并不能解决写-写的并发事务问题, 必须通过加锁的形式（行锁）

##### 共享锁: S 独占锁: X

互斥即是阻塞等待锁释放

1. S-S 兼容 
2. S-X 互斥  X-S互斥
3. X-X互斥

**注意：事务中采用的是两阶段锁协议, 当遇到第一个查询语句事务开启, 遇到第一个修改语句加锁, 事务提交锁释放**

##### 锁定语句

1. 读加S锁：别的事务可以获取S锁来读取数据, 阻塞写操作获取X锁, 直到锁释放

~~~mysql
SELECT ... LOCK IN SHARE MODE;
~~~

2. 读加X锁：阻塞获取S锁、X锁的事务, 直到锁释放

~~~mysql
SELECT ... FOR UPDATE;
~~~

#### 写操作

1. DELETE B+树中获取到该记录, 然后获取X锁, 进行DELETE MARK(可以看成锁定读)
2. UPDATE
   * 未修改键值, 并且修改列存储空间不变；B+树定位记录, 获取X锁, 原地修改
   * 未修改键值, 并且修改列的存储空间改变；B+树定位记录, 获取X锁, 删除该记录, 新增一条记录
   * 修改键值；先DELETE操作, 然后INSERT操作
3. INSERT 插入不加锁, 通过隐式锁保证事务未提交之前不被其他事务读取到

### 行锁类型

#### Record Locks

》即是前面所说的普通行锁

1. S
2. X

#### Gap Locks(间隙锁)

》加锁(Gap Locks)的形式防止插入幻影行 (防止往该记录前面的间隙插入记录,不包括记录本身)

注意：间隙锁只是在范围查找避免插入幻影行才加, 如果是通过主键精确查找则只是加普通行锁(记录锁)

#### Next-Key Locks

》加锁的形式避免插入幻影行并且对记录加锁

1. Record Locks 加记录锁
2. Gap Locks 加间隙锁

#### 隐式锁

一个事务执行INSERT 操作, 如果被插入的间隙有Gap锁, 那么INSERT 就会阻塞等待, 并且当前事务就会在该间隙加上插入意向锁.  但是普通情况下的INSERT是不加锁操作, 所以就有可能在其他事物中发生脏读, 脏写. 但是由于事务id的存在, 会判断该事务是不是活跃事务, 如果是就会帮助当前事务加X锁, 然后自己本身加锁, 进入等待状态

### 多粒度锁

#### 表锁

》表锁的粒度太粗, 导致并发性能低, 一般情况下不使用(在某些特殊情况下用到, 例如崩溃恢复)

1. 共享锁: S 
2. 独占锁: X

ALTER DROP 等DDL 语句, 同时其他查询语句会被阻塞, 是在Server层的**元数据锁**实现,并非表锁

可以手动开启表锁

~~~mysql
LOCK TABLES t READ;
LOCK TABLES t WRITE;
~~~

#### 意向锁

》为了在对表加S或者X锁之前快速判断记录是否被加了锁；意向锁之间是互相兼容的

1. 意向共享锁: IS
2. 意向独占锁: IX

#### AUTO-INC锁

》自增主键, 保证连续性

### 回头再看

#### 事务、隔离级别、MVCC、锁

MySQL是一个关系型事务系统数据库, 需要满足ACID特性. 同时MySQL也需要满足并发事务, 那么就会出现常规的并发数据问题(脏读、幻读、不可重复读)以及性能问题, MySQL通过隔离级别来平衡两者之间的关系. 

MVCC并发版本控制在可重复读模式及读提交模式下运行, 可显著提升读并发的性能(ReadView). MySQL默认在可重复读模式, 以避免不可重复读问题(并非其他的隔离级别无用, 而是在当前环境下可重复读是一种更优选择). 在写模式下由于会写当前最新数据为了保护数据安全, 通过加记录行锁实现(**事务中是两阶段锁**), 为了避免幻影行, 通过加间隙锁实现

InnoDB采用的是两阶段锁定协议, 在事务执行过程中, 第一个查询语句事务启动, 并且随时都可以执行锁定, 锁只有在执行COMMIT或者ROLLBACK的时候才会释放，并且所有的锁是在同一时刻被释放

#### 死锁

死锁是指两个或者多个事务在同一资源上相互占用, 并请求锁定对方占用的资源, 从而导致恶性循环的现象. 当多个事务试图以不同的顺序锁定资源时, 就可能会产生死锁. 多个事务同时锁定同一个资源时, 也会产生死锁. 数据库系统实现了各种死锁检测和死锁超时机制

#### 乐观锁、悲观锁

事务中在做数据库写操作的时候, UPDATE是会锁当前记录, 但是可能前置条件会先基于SELECT出的数据做逻辑判断, 所以, 在业务上可选两种锁模式来避免数据问题. 

1.  悲观锁, 假定会发生并发冲突, 屏蔽一切可能导致数据不完整的操作, 采用数据库锁机制(锁定读,需要读的情况下)
2.  乐观锁, 假定不会发生并发冲突, 只是在提交的时候检查是否违背数据完整性. 进入事务查询记录版本字段, 在提交数据时再次检测该记录版本, 如果变动则不予提交, 或自旋再次尝试. 