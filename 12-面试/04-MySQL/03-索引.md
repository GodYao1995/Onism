[TOC]

### 索引

1. 每个索引都对应一颗B+树, 叶子结点存储普通记录, 内结点存储目录项纪录
2. InnoDB引擎会自动为主键创建聚簇索引, 其叶子结点包含完整的用户记录(索引即记录)
3. 创建二级索引, 二级索引的叶子结点是二级索引列与主键值, 查完整记录需要回表
4. B+树每层结点是按照索引列从小到大的顺序排序组成双向链表, 每个页内的记录是按照索引列值从大到小的顺序组成单向链表. 如果是联合索引, 那么页面与记录按照联合索引的顺序, 依次排序
5. B+树的搜索是按照根结点开始.

#### 为什么使用B+树

##### Hash

1. 基于Hash表实现【Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法】
2. 精确查找
3. Hash冲突
4. 只能用于对等比较，不能进行范围查询

##### 链表

1. 不支持按照某个值或者区间查找
2. 频繁的插入删除不友好

##### 平衡二叉树

1. 若左子树不空，则左子树上所有节点的值均小于它的根节点的值

    若右子树不空，则右子树上所有节点的值均大于或等于它的根节点的值

    每个非叶子节点的左右子树的高度之差的绝对值（平衡因子）最多为1

2. 不支持范围查找、查找代价和树高有关

##### B树

1. 数据分布在节点，不需要全表扫描，加快访问速度
2. 范围查找需要遍历所有节点

##### B+树

1. 改进平衡二叉树，将所有的叶子结点采用双向链表链接，方便区间查找
2. 记录【或者记录的指针】存储在叶子节点，其他的节点是存储索引
3. 满足基本的三个需求【定值查找、区间查找，顺序和逆序】
4. 空间利用率更高，减少IO次数、磁盘读写效率更高

问题

B+树数据多，树高就会造成IO的访问次数多

1. 采用m叉树，可以减少IO次数
2. m不是越大越好，B+ 树的结构配合计算机磁盘存储页结构默认值为 16 KB，也就是说对于 B+ 树的节点，最好设置成页的大小（16 KB），这样一个 B+ 树上的节点就只会有一次 IO 读

#### 使用

##### 索引代价

1. 空间上, 每建立一个索引, 都需要建立一个B+树, 每个结点是一个大小为16K的数据页
2. 时间上, 修改记录, 都会修改B+树, 维护索引

##### 索引条件

> A B C D 四列, A B C 建立联合索引

ABC三列建立联合索引, 需要注意, 在索引B+树存储中, 先按照A排序, 如果A相同再按照B排序, 如果B相同则按照C排序

1. 全值匹配

~~~mysql
SELECT * FROM T WHERE A = 'Va' AND B = 'Vb' AND C = 'Vc'
~~~

全值匹配中WHERE子句的顺序是没有影响的, 查询优化器会分析优化； 联合索引三个列都可能被用到

2. 匹配左边的列

~~~mysql
SELECT * FROM T WHERE A = 'Va'						 -- 可用到 A
SELECT * FROM T WHERE A = 'Va' AND C = 'Vc' 		 -- 可用到 A
SELECT * FROM T WHERE C = 'Vc'						 -- 不可用
~~~

由于联合索引的实现方式, A B C 排序，所以想使用到联合索引的列, 搜索条件就必须联合索引最左边连续的列

3. 匹配列前缀

~~~mysql
SELECT * FROM T WHERE A like 'Mar%'
~~~

字符串列的排序也是按照每个字符排序的, 所以索引支持前缀

4. 匹配范围值

~~~mysql
SELECT * FROM T WHERE A > 'Va' AND A < 'Vz'
~~~

由于数据页与记录是按照A排序的, 页通过双向链表, 记录通过单向链表, 先找Va, 再找Vz, 然后取出即可

5. 精确匹配列并且范围匹配其他列

~~~mysql
SELECT * FROM T WHERE A = 'Va' AND B > 'Vb' AND B < 'Vn' AND C < 'Vc'
~~~

由于A是精确匹配可以用到索引, 并且得到的结果A是相同的, 并且B也是按照顺序的，所以B也可用到索引, B得到的结果可能是范围值, 所以C无法使用到索引, 只能遍历上一步的结果

6. 排序

> 注意：排序的列的排序顺序必须是一致的, 同升同降

~~~mysql
SELECT * FROM T ORDER BY A, B, C 
~~~

使用联合索引排序的列也必须是联合索引的顺序；如果搜索的列是左侧列, 那么剩下的连续列也是可用索引的

~~~mysql
SELECT * FROM T WHERE A = 'Va' ORDER BY B, C
~~~

如果搜索的列是非排序使用到索引列, 那么排序依然使用不到索引

~~~mysql
SELECT * FROM T WHERE D = 'Vd' ORDER BY A, B -- 不可使用到索引
~~~

如果排序的列包含一个非同一个索引列，那么排序久无法使用到索引

~~~mysql
SELECT * FROM T ORDER BY A, D -- D 不可使用到索引
~~~

7. 分组

   分组的列也必须是联合索引的列顺序一致

~~~mysql
SELECT A,B,C COUNT(*) FROM T GROUP BY A,B,C
~~~

**注意：索引列在搜索条件中不能是表达式的形式，否则无法使用索引**

##### 回表的代价

~~~mysql
SELECT * FROM T WHERE A > 'Va' AND A < 'Vz'
~~~

1. 该查询会访问两个索引, 二级索引 与 聚簇索引
2. 二级索引才用顺序IO(联合索引排序), 而聚簇索引使用随机IO(通过二级索引查询到的主键可能是分散的)

如果需要回表的次数很多, 那么才用二级索引的查询效率就不高；查询优化器会会优化，如果限制查询获取到记录少，就会选择二级索引+回表，反正就会选择全表扫描

~~~mysql
SELECT * FROM T WHERE A > 'Va' AND A < 'Vz'          -- 全表扫描 (假设记录很多)
SELECT * FROM T WHERE A > 'Va' AND A < 'Vz' LIMIT 10 -- 二级索引+回表
SELECT * FROM T WHERE ORDER BY A, B, C LIMIT 10		 -- 二级索引+回表
~~~

##### 覆盖索引

为了避免回表的代价，推荐查询的列只包含索引列

~~~mysql
SELECT A,B,C FROM T WHERE A = 'Va'
~~~

##### 建立索引

1. 只为搜索、排序、分组的列建立索引
2. **列的数据基数(非重复值)少，不建议建立索引；** 
3. 索引列的值尽可能小
4. 列字符串比较长，可以考虑建字符串的前缀索引(看情况)
5. 主键AUTO_INCREMENT属性，减少页分裂
6. 避免重复索引

##### 命中索引

1. like在匹配通配符开头的时候，无法索引
2. where中的or、函数、表达式无法命中索引
3. SQL语句中使用函数无法命中索引
4. = 号左边运算也不能命中索引
5. 联合索引【多个字段同时建立一个索引】，索引的必须全部排序使用 name、age、score，要不然不会命中

##### 回表查询

1. 聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据
2. 非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行

在InnoDB中，只有主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引。如果没有唯一键，则隐式的生成一个键来建立聚簇索引。当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再次进行回表查询。所以非聚簇索引查询都需要二次查询，也就是回表查询。

非聚簇索引也不一定要回表查询，如果查询的字段都建立了索引，并且全部命中。那么就不需要回表

##### 索引分类

1. 主键索引，数据列不允许重复，不允许为NULL，只能有一个主键索引

2. 普通索引，没有唯一性限制，✅允许为空

3. 唯一索引，数据列不允许重复❎，可以为NULL，可创建多个

4. 联合索引

5. 聚簇索引，不是单独的索引类型，而是一种数据存储方式

    叶节点存放一整行记录的索引被称为聚簇索引，其他的就称为非聚簇索引

6. 非聚簇索引
