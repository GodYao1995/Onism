[TOC]

### 幂等性

同一个操作,  执行多次的结果是一致的

#### 重试场景

大多数系统都不是单一的架构,  往往需要依赖其他的组件或者子系统.  如应用层面REST服务,  数据库层面,  消息队列层面、子系统RPC服务,  一旦调用某个服务"失败",  要么在主调用者重试,  要么系统自带重试机制,  结果就是可能对同一个操作造成不同的结果.  

**幂等性是系统服务对外一种承诺,  承诺只要调用接口成功,  外部多次调用对系统的影响是一致的**.  声明为幂等的服务会认为外部调用失败是常态,  并且失败之后必然会有重试

#### 幂等场景

针对查询以及删除的操作可以认为是幂等的,  但是如更新、新增的操作则不是幂等的.  

例如以下的SQL操作不是幂等的(只是做说明, 该SQL逻辑可通过并发扣减方案解决)

~~~sql
UPDATE T SET stock = stock - n WHERE UID = 1 AND stock - n > 0;
~~~

#### 解决办法

##### 1、唯一索引

通过对某个字段加唯一索引,  那么在多次新增时,  就会直接报错.  但是要求操作落在同一个库表.  

##### 2、Token

**保证幂等性,  即是,  保证如果当前的操作如果被处理过,  那么后续带有唯一标示的操作,  即认为是"同一操作",  不处理**.  核心的观点在于,  服务层判断该操作是否执行过.  采用Token的模式,  可以较好的适应大多数的情景.  实际上,  在进行开发过程中,  我们需要分析出哪些服务是需要幂等的.  

1. 在应用层执行操作之前,  **"静默"申请Token**,  执行操作携带Token
2. 服务检测是否携带Token,  并且该Token是否存在(存储Redis中),  存在即是该操作未被执行,  那么删除Token,  执行业务操作.  
3. 如果不存在该操作的Token,  那么该操作是重复执行的,  那么返回重复执行的标记.  

注意点：通常情况下,  需要先删除Token,  再执行操作.  

Token模式也存在缺点,  重试的情况通常来说是少量的,  但是为了少量的情况,  我们必须为每一个请求都生出Token,  这必然会对系统产生影响.  Token的生成可以采用snowfake等唯一算法. 

##### 3、防重表

为操作引入业务的唯一标示,  在执行操作是,  唯一标示作为防重表唯一索引.  这样由于防重表的唯一索引,  如果该操作执行过,  那么就会插入失败.  即使操作失败,  也可以利用数据库事务回滚操作.  

以此衍生出各个不同的幂等性的解决场景,  如通过流水号.  
