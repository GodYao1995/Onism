### 二分查找

#### 简单二分查找

1. 给定一个 n 个元素有序的（升序）整型数组 nums 
2. 一个目标值 target  
3. 写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1

~~~go
func BinarySearch(nums []int, target int) int {
    left := 0
    right := len(nums) - 1
    // 注意退出条件 left > right 保证区间查找完毕
    for left <= right {
        // 注意溢出
        mid := left + (right - left) >> 1
        // 三个范围
        if nums[mid] == target {
            return mid
        } else if nums[mid] < target {
            left = mid + 1					// [mid+1, right]
        } else if nums[mid] > target {		// [left, mid-1]
            right = mid - 1
        }
    }
    return -1
}
~~~

#### 查找第一个与target相等的元素

~~~go
func BinarySearchFirst(nums []int, target int) int {
    left := 0
    right := len(nums) - 1
    // [0, left)	(right, N-1]
    index := -1
    for left <= right {
        mid := left + (right - left) >> 1
        if nums[mid] == target {
            index = mid
            right = mid - 1
        } else if nums[mid] > target {
            right = mid - 1
        } else {
            left = mid + 1
        }
    }
    return index
}

func BinarySearchFirst(nums []int, target int) int {
    left := 0
    right := len(nums) - 1
    for left <= right {
        mid := left + (right - left) >> 1
        if nums[mid] >= target {
            right = mid - 1
        } else {
            left = mid + 1
        }
    }
    if left < len(nums) && nums[left] == target {
        return left
    }
    return -1
}
~~~

#### 查找最后一个与target相等的元素

~~~go
func BinarySearchLast(nums []int, target int) int {
    left := 0
    right := len(nums) - 1
    index := -1
    for left <= right {
        mid := left + (right - left) >> 1
        if nums[mid] == target {
            index = mid
            left = mid + 1
        } else if nums[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    return index
}

func BinarySearchLast(nums []int, target int) int {
    left := 0
    right := len(nums) - 1
    for left <= right {
        mid := left + (right - left) >> 1
        if nums[mid] <= target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    if right >= 0 && nums[right] == target {
        return right
    }
    return -1
}
~~~

#### 搜索插入位置

> 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。
>
> 如果目标值不存在于数组中，返回它将会被按顺序插入的位置

~~~go
func searchInsert(nums []int, target int) int {
    left := 0
    right := len(nums) - 1
    for left <= right {
        mid := left + (right - left) >> 1
        if target <= nums[mid] {
            right = mid - 1
        } else {
            left = mid + 1
        }
    } 
    return left 
}
~~~

