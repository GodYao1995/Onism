[TOC]

### Tree

#### 定义

>  非线性的，逻辑上的数据结构

1. 元素/节点
2. **根节点/Root**
3. 父节点、子节点、兄弟节点
4. 度
5. **左节点、右节点**
6. **左子树、右子树**
7. **叶子节点：无子节点的节点**
8. 节点深度：根节点到该节点所经历的边的个数
9. 节点高度：该节点到叶子节点最长(边)路径
10. 节点层数：节点深度 + 1
11. 树高度：根节点的高度

#### 二叉树

> 每个节点，最多有两个子节点，左节点、右节点

##### 满二叉树

> 1. 除叶子节点外，每个节点都有左右两个子节点（所有非叶子结点的度都是2）（完美二叉树）
> 2. 深度为k，那么节点书2^k - 1

##### 完全二叉树

> 若设二叉树的深度为k
>
> 1. 除第 k 层外，其它各层 (1～k-1) 的结点数都达到最大个数
> 2. 第k 层所有的结点都**连续集中在最左边**
> 3. 完全二叉树从根结点到倒数第二层满足满二叉树

##### 二叉查找树

##### 平衡二叉树

##### 红黑树

#### 表示

##### 链式

##### 数组

> 用数组存储完全二叉树是最节省内存的一种方式（靠左排列的原因）

#### 遍历

##### DFS

> 深度优先遍历，Depth-First-Search

###### 前序遍历

> 根、左子树、右子树

~~~go
func preorderTraversal(root *TreeNode) []int {
    var res []int
    
    var preOrder func(*TreeNode, *[]int)
    preOrder = func(root *TreeNode, res *[]int) {
        if root != nil {
            *res = append(*res, root.Val)
            preOrder(root.Left, res)
            preOrder(root.Right, res)
        }
    }
    
    preOrder(root, &res)
    return res
}
~~~

非递归遍历

~~~go
func preorderTraversal(root *TreeNode) []int {
    var res []int
    stack := make([]*TreeNode, 0)
    stack = append(stack, root)
    for root != nil && len(stack) > 0 {
        node := stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        res = append(res, node.Val)
        if node.Right != nil {
            stack = append(stack, node.Right)
        }
        if node.Left != nil {
            stack = append(stack, node.Left)
        }
    }
    return res
}
~~~

###### 中序遍历

> 左子树、根、右子树

~~~go
func inorderTraversal(root *TreeNode) []int {
    var res []int
    var inOrder func(*TreeNode, *[]int)
    inOrder = func(root *TreeNode, res *[]int) {
        if root != nil {
            inOrder(root.Left, res)
            *res = append(*res, root.Val)
            inOrder(root.Right, res)
        }
    }
    inOrder(root, &res)
    return res
}
~~~

###### 后序遍历

> 左子树、右子树、根

~~~go
func postorderTraversal(root *TreeNode) []int {
    var res []int
    var postOrder func(*TreeNode, *[]int)
    postOrder = func(root *TreeNode, res *[]int) {
        if root != nil {
            postOrder(root.Left, res)
            postOrder(root.Right, res)
            *res = append(*res, root.Val)
        }
    }
    postOrder(root, &res)
    return res
}
~~~

~~~go
func postorderTraversal(root *TreeNode) []int {
    var res []int
    dfs(root, &res)
    return res
}
// DFS
func dfs(root *TreeNode, res *[]int) {
    if root != nil {
        dfs(root.Left, res)
        dfs(root.Right, res)
        *res = append(*res, root.Val)
    }
}
~~~

##### BFS

> 广度优先遍历