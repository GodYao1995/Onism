[TOC]

### 架构与历史

#### 逻辑架构

> 存储引擎插件架构

<img src="images/MySQL逻辑架构.svg" alt="MySQL逻辑架构" style="zoom:150%;" />

##### 服务层

>   MySQL功能层

1.  连接器、查询缓存、分析器、优化器、执行器
2.  涵盖大部分的MySQL功能，以及内置函数
3.  跨存储引擎功能：存储过程、视图、触发器

###### 连接管理(连接器)

> 每个客户端连接都会拥有服务器一个线程，每个连接的查询都是在这个单独的线程，并且服务器会缓存线程

1. 认证
2. 权限

###### 分析与优化(分析器与优化器)

> 解析查询、创建解析树，进行各种优化

1. (SELECT)查询缓存
2. 重写查询
3. 表的读取顺序
4. 合适的索引

##### 存储引擎

> 负责MySQL中数据的存储和提取；服务器通过API与存储引擎通信。

#### 并发控制

> 多个查询同一时刻修改数据，产生并发控制的问题。加锁是一种直接并且简单的方式来进行并发控制。

##### 读写锁

> 通过实现一个由两种类型的锁(共享锁、排他锁)组成的锁系统来解决并发问题。也称为读锁、写锁

1. 读锁是共享的，互不干扰、互不阻塞
2. 写锁是排他的，阻塞读与写

##### 锁粒度

加锁是为了数据安全，但是加锁也需要消耗资源，例如获得锁、检查锁等管理锁的操作。并且在提高共享资源并发性的方式上，加锁还需要对对象有选择性，最理想的方式是只对修改的数据片进行精确的锁定，锁定的数据量越少，并发程度越高。

在锁的开销与数据的安全性之前寻求平衡，大多数是在表上加行锁，并用各种复杂方式实现。

**MySQL存储引擎实现自己的锁策略和锁粒度**。

###### 表锁

> 最小开销的锁策略：修改操作锁定整张表

一个用户在进行修改操作，必须先获得写锁，同时会阻塞其他的读写操作。写锁的优先级高于读锁，因此一个写锁请求可能会被插入读锁队列前面。虽然是存储引擎实现并且管理锁，但是服务器会为某些DDL操作(ALTER)使用表锁，而忽略存储引擎的锁机制。

###### 行级锁

> 最大程度支持并发，但是开销也是最大的锁开销

**行级锁只在存储引擎实现。**

#### 事务

##### 概念

> 一组原子性的SQL查询，一个独立的工作单元。表现出来就是：事务内的SQL语句要么全部执行成功，要么全部执行失败。

~~~mysql
START TRANSACTION;
....SQL1;
....SQL2;
COMMIT;
~~~

##### 特性

> 单纯的事务概念对于需要满足事务处理系统是不够的，必须通过严格的ACID(原子性、一致性、隔离性、持久性)测试

###### 原子性

> 一个事务必须被视为一个不可分割的最小工作单元，整个事务中所有操作要么全部提交成功，那么全部失败回滚

###### 一致性

> 确保数据库总数从一种状态转换到另一个一致性状态，即是事务最终没有提交，那么事务中的修改不会保存到数据库中

###### 隔离性

> 通常来说(取决于不同的隔离级别)，一个事务所做的修改在最终提交之前，对其他的事务是不可见的

###### 持久性

> 一旦事务提交，则其所做的修改就会永久的保存到数据库中(不是100%，需要更多的持久策略)

##### 隔离级别

> 四种隔离级别，每一种都规定了一个事务中所做的修改，是否对其他的事务可见

###### 读未提交 READ UNCOMMITTED

> 该级别下，事务所做的修改即使没有提交，对其他事物也是可见的。

表现：事务可以读取其他未提交的数据，导致读取到不期望的数据，该过程称为脏读

###### 读提交 READ COMMITTED

> 一个事务从开始直到提交之前，所做的修改对其他事务都是不可见的。

表现：一个事务开始，只能看见已经提交的事务所做的修改。在一个事务中，可能发生第一次读取到另一个事务未修改的数据，第二次读取到事务提交后的数据，也就是在一个事务两次查询得到不一样的结果。所以此级别也称为不可重复读

###### 可重复读 REPEATABLE READ

> 在同一个事务中多次读取同样记录的结果是一致的。MySQL默认的隔离级别。

可重复读无法解决幻读，幻读是指，当某个事务读取某个范围的记录是，另一个事务在该范围内插入了新的记录，当之前的事务再次读取该范围的记录是，产生幻行。InnoDB通过MVCC解决幻读。

###### 可串行化 SERIALIZABLE

> 强制事务串行执行，避免幻读。此级别下，读取的每一行数据都会加锁

##### 死锁

> 两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源

1. 死锁检测、死锁超时机制
2. 锁的行为和顺序是和存储引擎相关
3. **InnoDB采用：将持有最少行级排他锁的事务进行回滚(死锁回滚算法)**

##### 事务日志

> 事务日志记录事务修改行为，写事务日志是一块区域的顺序IO，而不是直接写磁盘的随机IO

1. Write-Ahead Loggin 先写日志，【后台空闲】在写磁盘，效率高【更新数据写两次磁盘】
2. 如果写了事务日志，那么系统崩溃，存储引擎也能恢复这部分数据

##### MySQL中的事务

> 提供InnoDB、NDB Cluster两种事务引擎

###### 自动提交 AUTOCOMMIT

MySQL默认采用自动提交模式，即是：**如果不是显式的开始一个事务，则每个查询都被当作一个事务执行提交操作**

~~~mysql
mysql> show variables like 'autocommit';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| autocommit    | ON    |
+---------------+-------+
1 row in set (0.01 sec)
mysql> set autocommit = 1;
~~~

如果修改为 OFF或者0，那么必须显示的COMMIT或者ROLLBACK，然后该事务结束

###### 隐式与显式锁定

**InnoDB采用两阶段锁定协议**。事务执行过程中随时(需要时)锁定，并且当COMMIT或者ROLLBACK(事务结束)时才会释放，并且所有的锁在同一时刻被释放，**此过程时隐式的，并且InnoDB会根据隔离级别在需要的时候自动加锁**。

也支持非SQL规范的语句显示锁定

~~~mysql
mysql> SELECT ... LOCK IN SHARE MODE;
mysql> SELECT ... FOR UPDATE;
~~~

##### 多版本并发控制

> 大多数事务型存储引擎不是简单的实现行级锁，都同时实现了多版本并发控制MVCC。

可以认为MVCC是行锁的变种，避免了加锁的操作，开销更低。实现非阻塞读，写操作锁定必要的行。

**MVCC的实现，是通过保存数据在某个时间点的快照来实现的。**

1. 不管执行多长时间，每个事务看到的数据都是一致的。
2. 事务开始时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的

**InnoDB MVCC**

> 通过每行记录后面保存两个隐藏列实现，一个是"创建时间"，一个是"删除时间", 实际上存储的是系统版本号。

1. 每开始一个新的事务，系统版本号就会自动递增。
2. 事务开始时刻的系统版本号会作为事务版本号，用来和查询到的每行记录的版本号比较

在可重复读情况下，具体MVCC针对不同的操作如下【只在可重复读与读提交隔离级别下工作】

**SELECT**

1. 查找版本号早于当前事务版本号的数据行
2. 行的删除版本要么未定义，要么大于当前事务版本号

**INSERT**

1. 为新插入的每一行保存当前系统版本号作为行版本号

**DELETE**

1. 为删除的每一行保存当前系统版本号作为删除标示

**UPDATE**

1. 为插入一行新记录保存当前系统版本号作为行版本号，同时保存当前系统系统版本号到原来的行作为行删除标示

#### 存储引擎

##### InnoDB

> InnoDB引擎是MySQL默认的事务型引擎，处理大量短期(大部分正常提交)的事务，性能高，并且具有自动恢复特性。

~~~mysql
mysql> show table status like 'user' \G;
*************************** 1. row ***************************
           Name: user
         Engine: InnoDB		-- 存储引擎
        Version: 10
     Row_format: Dynamic
           Rows: 1
 Avg_row_length: 16384
    Data_length: 16384
Max_data_length: 0
   Index_length: 81920		-- 索引大小
      Data_free: 0
 Auto_increment: 2
    Create_time: 2021-05-10 10:10:15
    Update_time: 2021-05-11 17:28:04
     Check_time: NULL
      Collation: utf8mb4_0900_as_cs
       Checksum: NULL
 Create_options: 
        Comment: 
1 row in set (0.04 sec)
~~~

1. InnoDB的数据存储在表空间(tableSpace), 由一系列数据文件组成
2. InnoDB采用**MVCC支持高并发**，实现四个标准的隔离级别，默认是可重复读，并且同通过间隙锁策略防止幻读(不仅仅通过锁定查询的行，还对索引中的间隙锁定，防止幻影行插入)
3. InnoDB的表基于**聚簇索引建立**，对主键查询有很高的性能，并且二级索引必须包含主键列(所以主键列应当尽可能小)
4. 从磁盘读取数据采用可预测性读
5. 加快插入操作的插入缓冲区
6. 在内存中创建Hash索引加速读操作的自适应哈希索引
7. 支持真正的热备份