[TOC]

### 编程范式

> 左耳朵耗子

#### 切片

> 切片是结构体，底层引用了数组

~~~go
type slice struct {
	array unsafe.Pointer
	len   int
	cap   int
}
~~~

共享

> 共享了底层的数组，也就是数据共享了

~~~go 
foo := make([]int64, 5) // cap = len = 5
bar := foo[1:4]
bar[1] = 99
fmt.Printf("%+v, %d, %d, %p\n", foo, len(foo), cap(foo), foo) // [0 0 99 0 0] 5 5 0xc00001a180
fmt.Printf("%+v, %d, %d, %p\n",bar, len(bar), cap(bar), bar)  // [0 99 0] 3 4     0xc00001a188
~~~

扩容

> 2倍扩容

~~~go
foo := make([]int, 5) // cap = len = 5
bar := foo[1:4]
foo = append(foo, 100)
// [0 0 0 0 0 100], 6, 10, 0xc00012e000
fmt.Printf("%+v, %d, %d, %p\n", foo, len(foo), cap(foo), foo) 
// [0 0 0], 3, 4, 0xc000118038
fmt.Printf("%+v, %d, %d, %p\n",bar, len(bar), cap(bar), bar) 
~~~

#### 深度比较

> 需要比较实例中数据是否相等

~~~go
sl1 := []int{1, 2, 3}
sl2 := []int{1, 2, 3}
if reflect.DeepEqual(sl1, sl2) {
    log.Println("sl1 = sl2")
}
m1 := map[string]int{
    "a": 1,
    "b": 2,
}
m2 := map[string]int{
    "a": 1,
    "b": 2,
}
if reflect.DeepEqual(m1, m2) {
    log.Println("m1 = m2")
}
~~~

#### 接口编程

~~~go
package main

import "log"

// 业务类型与控制逻辑通过接口解耦
type PrintNameFace interface {
	PrintStr()
}
// 业务类型
type Country struct {
	Name string
}

type City struct {
	Name string
}

// 控制逻辑
func (c *Country) PrintStr() {
	log.Println(c.Name)
}

func (c *City) PrintStr() {
	log.Println(c.Name)
}

func main() {
	cr := &Country{Name: "China"}
	ct := &City{Name: "BeiJin"}
	
    // 接口完整性检查
    // var _ PrintNameFace = (*Country)(nil)
	// var _ PrintNameFace = (*City)(nil)
    
	var cri PrintNameFace = cr
	var cti PrintNameFace = ct

	cri.PrintStr()
	cti.PrintStr()
}
~~~

#### 时间

> 1. 时间极其复杂，时区、格式、精度
> 2. 在 Go 语言中，使用 `time.Time` 和 `time.Duration` 两个类型

#### 性能提示

> 1. 转换请使用strconv包
> 2. 避免将String转换为Byte
> 3. 尽量提前估算好切片的容量，避免重新申请
> 4. 使用`StringBuffer` 或是`StringBuild` 来拼接字符串
> 5. 使用并发gorouitne，然后使用waitgroup同步
> 6. 使用sync.Pool重用对象
> 7. 使用 lock-free的操作，避免使用 mutex，尽可能使用 `sync/Atomic`包
> 8. 使用 `bufio.NewWrite()` 和 `bufio.NewReader()` 可以带来更高的I/O性能
> 9. 使用 `regexp.Compile()` 编译正则表达式
> 10. 使用 [protobuf](https://github.com/golang/protobuf) 或 [msgp](https://github.com/tinylib/msgp) ，更高性能的协议
> 11. 使用map的时候，使用整型的key会比字符串的要快

#### 错误处理

> 1. 函数支持多返回值，将业务语义与控制语义区分开
> 2. 可以用空白标识符忽略错误
> 3. 错误可以自定义扩展
> 4. 推荐采用包装错误[github.com/pkg/errors](https://github.com/pkg/errors)

#### 资源清理

~~~go
defer resp.body.close()

f.close()
~~~

#### Functionnal Options

可选配置选项问题

~~~go
type Queue struct {
	Name     string
	MaxLimit int
	// monitor
	MonitorInterval int
}

type QueueOption func(*Queue)

func WithMaxLimit(max int) QueueOption {
	return func(q *Queue) {
		q.MaxLimit = max
	}
}

func WithMonitorInterval(seconds int) QueueOption {
	return func(q *Queue) {
		q.MonitorInterval = seconds
	}
}
func NewQueue(name string, options ...QueueOption) *Queue {
	queue := &Queue{name, 10, 5}
	for _, o := range options {
		o(queue)
	}
	return queue
}
~~~

