[TOC]

### 测试

#### 单元测试

> 测试文件 _test.go结尾

1. 测试用例名称一般命名为 `Test` 加上待测试的方法名
2. 测试用的参数有且只有一个， `t *testing.T`

##### 简单测试

~~~go
func TestAdd(t *testing.T) {
	if got := Add(1, 2); got != 3 {
		t.Errorf("1 + 2 expected be 3, but %d got", got)
	}

	if got := Add(-10, -20); got != -30 {
		t.Errorf("-10 + -20 expected be -30, but %d got", got)
	}
}
~~~

##### 测试命令

~~~bash
go test
go test -v
go test -cover           # 测试覆盖度
go test -run TestAdd -v  # 支持部分测试执行 ^ * 部分正则
~~~

##### 子测试

> table-driven tests. (可以用一些常见的单词got、want、expected)

一般情况下，比较推荐使用子测试，可读性好

~~~go
func Add(a, b int) int {
	return a + b
}
func TestAdd(t *testing.T) {
	type args struct {
		a int
		b int
	}
	tests := []struct {
		name string
		args args
		want int
	}{
		{
			name: "first",
			args: args{
				a: 2,
				b: 3,
			},
			want: 5,
		},
		{
			name: "second",
			args: args{
				a: 4,
				b: 7,
			},
			want: 12,
		},
	}
    t.Helper()  // 帮助查看错误位置
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := Add(tt.args.a, tt.args.b); got != tt.want {
				t.Errorf("Failed: got %d != want %d", got, tt.want)
			}
		})
	}
}
~~~

##### 测试准备

> TestMain m.Run()会自动执行测试文件， 所以可以在前后执行相同的逻辑

~~~go
func setup() {
	log.Println("test setup")
}

func teardown() {
	log.Println("test teardown")
}

func TestMain(m *testing.M)  {
	setup()
	code := m.Run()
	teardown()
	os.Exit(code)
}
~~~

#### 基准测试

> 测试性能

基准测试用例的定义如下

1. 函数名必须以 `Benchmark` 开头，后面一般跟待测试的函数名
2. 参数为 `b *testing.B`
3. 执行基准测试时，需要添加 `-bench` 参数

~~~go
func BenchmarkName(b *testing.B){
    // ...
}
~~~

报告说明

~~~go
type BenchmarkResult struct {
    N         int           // 迭代次数
    T         time.Duration // 基准测试花费的时间
    Bytes     int64         // 一次迭代处理的字节数
    MemAllocs uint64        // 总的分配内存的次数
    MemBytes  uint64        // 总的分配内存的字节数
}
~~~

##### 测试命令

~~~bash
 go test -benchmem -bench .
~~~

##### 简单基准

~~~go
func BenchmarkAdd(b *testing.B) {
	// 耗时操作
	// 重置时间
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		Add(i, i+1)
	}
}
~~~

##### 测试并发

单例模式

~~~go
package main

import "sync"

type LazySingleton struct {}

var lazySingleton *LazySingleton
var once sync.Once

func GetLazyInstance() *LazySingleton {
	if lazySingleton != nil {
		once.Do(func() {
			lazySingleton = &LazySingleton{}
		})
	}
	return lazySingleton
}
~~~

测试

~~~go
func BenchmarkGetLazyInstance(b *testing.B) {
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			assert.Equal(b, GetLazyInstance(), GetLazyInstance())
		}
	})
}
~~~
