[TOC]

### 数组

#### 数组

线性连续的数据结构、分配**连续的存储空间**、访问效率高. 但查找、删除、添加都需要从头遍历

由于数组的每个元素类型一致, 知道了数组地址, 即可很方便的计算出其他元素的地址.

#### 栈

##### 定义

限制型数据结构、可以线性数组实现、链表实现

1. 栈顶
2. 栈底
3. 先进后出(后进先出)

##### 题型

###### minStack

~~~go
type MinStack struct {
    stack []int
    min []int
}

func Constructor() MinStack {
    return MinStack{
        stack: []int{},
        min: []int{math.MaxInt64},
    }
}

func (this *MinStack) Push(val int)  {
    this.stack = append(this.stack, val)
    if len(this.min) == 0 {
         this.min = append(this.min, val)
    } else {
        min := this.GetMin()
        if val < min {
            this.min = append(this.min, val)
        } else {
            this.min = append(this.min, min)
        }
    }
}

func (this *MinStack) Pop()  {
    this.min = this.min[:len(this.min) - 1]
    this.stack = this.stack[:len(this.min) - 1]
}

func (this *MinStack) Top() int {
    return this.stack[len(this.stack) - 1]
}

func (this *MinStack) GetMin() int {
    return this.min[len(this.min) - 1]
}
~~~

#### 队列

##### 定义

限制型数据结构、可以数组线性、链表实现

1. 队首
2. 队尾
3. 先进先出

##### 题型

###### 栈实现队列

~~~go
type MyQueue struct {
    in []int
    out []int
}

func Constructor() MyQueue {
    return MyQueue{
        in: make([]int, 0),
        out: make([]int, 0),
    }
}

func (this *MyQueue) Push(x int)  {
    this.in = append(this.in, x)
}

func (this *MyQueue) Pop() int {
    if len(this.out) != 0 {
        val := this.out[len(this.out) - 1]
        this.out = this.out[:len(this.out) - 1]
        return val
    }
    for len(this.in) != 0 {
        val := this.in[len(this.in) - 1]
        this.in = this.in[:len(this.in) - 1]
        this.out = append(this.out, val)
    }
    val := this.out[len(this.out) - 1]
    this.out = this.out[:len(this.out) - 1]
    return val
}

func (this *MyQueue) Peek() int {
    if len(this.out) != 0 {
        val := this.out[len(this.out) - 1]
        return val
    }
    for len(this.in) != 0 {
        val := this.in[len(this.in) - 1]
        this.in = this.in[:len(this.in) - 1]
        this.out = append(this.out, val)
    }
    val := this.out[len(this.out) - 1]
    return val
}

func (this *MyQueue) Empty() bool {
    return len(this.in) == 0 && len(this.out) == 0
}
~~~
