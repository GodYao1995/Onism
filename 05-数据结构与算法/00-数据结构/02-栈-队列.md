[TOC]

### 栈与队列

#### 数组与字符串

> 线性连续的数据结构

1. CPU预读机制友好、访问效率高
2. 必须分配**连续的存储空间**、扩容不友好
3. 查找、删除、添加都需要从头遍历

#### 栈

##### 定义

> 限制型数据结构、可以线性实现、亦或链式实现

1. 栈顶
2. 栈底
3. 先进后出(后进先出)

##### 题型

###### minStack

~~~go
type MinStack struct {
    stack []int
    min []int
}

func Constructor() MinStack {
    return MinStack{
        stack: []int{},
        min: []int{math.MaxInt64},
    }
}

func (this *MinStack) Push(val int)  {
    this.stack = append(this.stack, val)
    if len(this.min) == 0 {
         this.min = append(this.min, val)
    } else {
        min := this.GetMin()
        if val < min {
            this.min = append(this.min, val)
        } else {
            this.min = append(this.min, min)
        }
    }
}

func (this *MinStack) Pop()  {
    this.min = this.min[:len(this.min) - 1]
    this.stack = this.stack[:len(this.min) - 1]
}

func (this *MinStack) Top() int {
    return this.stack[len(this.stack) - 1]
}

func (this *MinStack) GetMin() int {
    return this.min[len(this.min) - 1]
}
~~~

#### 队列

##### 定义

> 1. 限制型数据结构、可以数组线性实现、亦或链式实现
> 2. 常用广度优先搜索

1. 队首
2. 队尾
3. 先进先出

##### 题型

###### 栈实现队列

~~~go
type MyQueue struct {
    in []int
    out []int
}

func Constructor() MyQueue {
    return MyQueue{
        in: make([]int, 0),
        out: make([]int, 0),
    }
}

func (this *MyQueue) Push(x int)  {
    this.in = append(this.in, x)
}

func (this *MyQueue) Pop() int {
    if len(this.out) != 0 {
        val := this.out[len(this.out) - 1]
        this.out = this.out[:len(this.out) - 1]
        return val
    }
    for len(this.in) != 0 {
        val := this.in[len(this.in) - 1]
        this.in = this.in[:len(this.in) - 1]
        this.out = append(this.out, val)
    }
    val := this.out[len(this.out) - 1]
    this.out = this.out[:len(this.out) - 1]
    return val
}

func (this *MyQueue) Peek() int {
    if len(this.out) != 0 {
        val := this.out[len(this.out) - 1]
        return val
    }
    for len(this.in) != 0 {
        val := this.in[len(this.in) - 1]
        this.in = this.in[:len(this.in) - 1]
        this.out = append(this.out, val)
    }
    val := this.out[len(this.out) - 1]
    return val
}

func (this *MyQueue) Empty() bool {
    return len(this.in) == 0 && len(this.out) == 0
}
~~~

#### 哈希表

> 哈希表、散列表，由数组扩展而来

1. 通过Hash函数将Key映射为数组下标(Hash值)，并且该数组下标位置存储一个Value
2. Hash函数可能出现不同的Key计算出相同的Hash值，造成冲突
    * 开放地址法
    * 链表法
