[TOC]

### 日志系统: 一条更新语句如何执行

》更新SQL语句的执行过程与查询过程基本一致, 只不过涉及了两个日志模块

》"整个流程操作在一个事务中(事务ID), redo log 与 binlog 对应"

#### SQL Update Flow

1.  执行器通过引擎获取到需要修改的行, 读取到内存(或改记录所在页已经加载到内存)
2.  执行器拿到数据后更新, 然后调用接口写入
    1. 引擎将新数据更新到内存
    2. 同时将记录写入redo log, 此时redo log处于prepare状态, 告知执行器完成, 随时可以提交事务
3.  执行器生成binlog, 并且写入磁盘
4.  执行器调用引擎提交事务接口, 将redo log 状态改为commit, 更新完成

![MySQL-SQL](./images/MySQL-SQL.svg)

#### redo log

重做日志(属于InnoDB引擎部分), 记录了这个页做了什么改动

~~~mysql
innodb_flush_log_at_trx_commit=1  # 表示每次事务的redolog都直接持久化到磁盘; 推荐此设置;
~~~

##### 原因

1.  如果每次更新都需要去磁盘中查询出来,执行器修改,然后在写回磁盘,那么整个IO成本和查询成本很高
2.  MySQL采用WAL技术, Write-Ahead Logging, 即是先写日志, 再写磁盘【空闲的时候】

##### 过程

1.  redo log日志模块隶属于InnoDB引擎, 是固定大小的, 循环写, 不能持久保存, 比如四个文件
2.  write_pos就是移动一直写redo log文件, checkpoint擦除写的数据, 并且将该数据更新到数据文件
3.  如果write_pos追上checkpoint, 那么就必须停下来, 让checkpoint先擦除推进

![redo-log](./images/redo-log.svg)

##### 结果

1.  提高了处理更新的效率(顺序写日志比些随机写磁盘更快)
2.  拥有crash-safe能力, 只要写了redo log日志, 就算数据库异常重启, 之前提交的数据不会丢失

#### binlog

Server层的日志, 称为归档日志

~~~mysql
sync_binlog=1 # 每次事务的 binlog 都持久化到磁盘; 推荐此设置;
~~~

为什么有两份日志？

MySQL自带的MyISAM引擎没有crash-safe能力, binlog只能用于归档, 记录所有的逻辑操作. InnoDB引擎是后来以插件形式引入, 并且提供redo log来提供crash-safe能力

区别如下: 

|                   binlog                   |                  redo log                  |
| :----------------------------------------: | :----------------------------------------: |
|                 Server 层                  |               InnoDB引擎 层                |
|               追加写多个文件               |              循环写, 会被擦除              |
|          宕机, 可能记录就会不成功          |                 crash-safe                 |
| 逻辑日志: 记录原始SQL语句模式或ROW记录格式 | 物理日志: 记录的是在某个数据页做了什么修改 |

注意: binlog 是无crash-safe

当数据库 crash 后, 想要恢复**未刷盘但已经写入 redo log 和 binlog 的数据**到内存时, binlog 是无法恢复的. 虽然 binlog 拥有全量的日志, 但没有一个标志让 innoDB 判断哪些数据已经刷盘, 哪些数据还没有. 

但 redo log 不一样, 只要刷入磁盘的数据, 都会从 redo log 中抹掉, 数据库重启后, 直接把 redo log 中的数据都恢复至内存就可以了. 这就是为什么 redo log 具有 crash-safe 的能力, 而 binlog 不具备. 

#### 问题

##### 为什么需要两段式提交？

1. 存储引擎层与server层之间采用的是内部XA(保证两个事务的一致性）
2. **主要保证redo log和binlog的原子性, 两份日志的逻辑性一致**

**假设法**

1.  假设先写redo log, 还没写完binlog, 崩溃恢复事务无效, 那么binlog就少记录了SQL语句, 所以从binlog恢复就导致少了数据
2.  假设先写binlog后crash, 没写redo log, 崩溃恢复事务无效, 但是binlog已经记录了SQL逻辑, 所以从binlog恢复数据就会造成多了数据

##### 两阶段提交

目的是保证和binlog的数据一致性

流程

1.  引擎将新数据更新到内存中, 同时将这个更新操作记录到redo log里面,此时redo log处于prepare状态
2.  告知执行器执行完成了, 随时可以提交事务
3.  执行器生成这个操作的binlog, 并把binlog写入磁盘
4.  执行器调用引擎的提交事务接口, 引擎把刚刚写入的redo log改成提交(commit)状态, 更新完成

阶段

1.  redo log 【prepare】
2.  执行器写binlog
3.  redo log 【commit】

情况

1. 如果redo log prepare, binlog失败, 事务回滚, 数据一致, 情况合理
2. **如果binlog成功, redo log commit失败,崩溃恢复时,由于binlog和prepare完整, 会认可这个事务, 然后commit, 数据一致**

#### 备份

根据数据的重要性, 进行一周一备, 或者一天一备份

1.  找到最近的一次全量备份, 然后恢复临时库
2.  从备份节时间点开始, 取出binlog, 重放数据
3.  binlog恢复的数据不一定完整, 可能由于业务操作插入了很多错误语句