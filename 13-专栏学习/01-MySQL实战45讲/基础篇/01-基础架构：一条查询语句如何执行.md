[TOC]

### 基础架构：一条SQL查询语句是如何执行的？

》看待一件事，先鸟瞰全貌，从高纬度理解问题，再深入局部

MySQL: My Ess Que Ell

~~~mysql
mysql> select * from T where id=10；
~~~

#### MySQL架构示意图

<img src="images/MySQL逻辑架构.svg" alt="MySQL逻辑架构" style="zoom:150%;" />

#### Server

>   MySQL功能层

1.  连接器、查询缓存、分析器、优化器、执行器
2.  涵盖大部分的MySQL功能，以及内置函数
3.  跨存储引擎功能：存储过程、视图、触发器

##### 连接器

1.  建立连接[TCP, C/S架构]

~~~bash
msyql -u $user -h $host -P $port -p
~~~

2.  获取权限

    连接器去权限表中查询你拥有的权限，一旦通过权限就会保存在该连接中

3.  维持和管理连接

    ~~~mysql
    mysql> show processlist;
    ~~~
    
    *   客户端如果一直处于静默状态，MySQL默认是8小时后就会断开【wait_timeout控制】
    *   客户端如果持续请求，那么就会使用同一个连接，也就是建立了长连接
    *   如果查询几次就断开，那么称为短连接

长连接

建立连接的过程很复杂，建议使用长连接

1. 全部都是长连接,MySQL内存涨的很快，因为MySQL在执行过程中临时使用的内存是在连接里面的, 需要断开才会释放内存，长期积累就会造成内存占用太大，被系统杀死，造成MySQL重启

3.  解决办法
    * 定期断开长连接
    
    * 5.7版本以上, 可以在执行一次大的操作后,通过执行mysql_reset_connection来做初始化连接资源, 这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态. 但是会有以下影响
    
      返回值： 0表示成功，非0表示发生了错误
    
      * 回滚活跃事务并重新设置自动提交模式 
      * 释放所有的表锁 
      * 关闭或删除所有的临时表 
      * 重新初始化会话的系统变量值 
      * 丢失用户定义的变量设置 
      * 释放prepared语句 
      * 关闭handler变量 
      * 将last_insert_id()的值设置为0 
      * 释放get_lock()获取的锁 
      * 清空通过mysql_bind_param()调用定义的当前查询属性 

##### 查询缓存

连接建立完成，执行逻辑来到第二步：查询缓存

1.  MySQL拿到一个请求，就会去查询缓存 Key-Value模式
2.  Key代表SQL语句、Value是查询的值
3.  如果查询缓存成功就会直接返回，效率非常高
4.  大多数情况下不建议使用查询缓存，只要表有更新，那么缓存就会失效，所以很难命中
5.  可以指定参数query_cache_type设置成DEMAND，所有的查询语句不适用查询缓存
6.  单独语句使用

~~~mysql
mysql> select SQL_CACHE * from T where ID = 10;
~~~

7.  MySQL8.0废弃了查询缓存

##### 分析器

1.  语义检查：分析SQL语句的关键字、分析出SQL中的列是否存在表中
2.  语法检查：分析整体SQL语句的MySQL语法正确性

##### 优化器

1.  确定使用哪个索引【怎么选择索引】、确定连表的顺序等
2.  将分析器生成的解析树转换成执行计划，评估最后确定真正的执行方案

##### 执行器

1.  开始执行语句
2.  判断是否对这个表有操作权限，有则通过
3.  打开表，执行器拿着SQL语句通过表引擎的定义去调用接口

#### 存储引擎

负责存储与数据的提取

1.  负责数据的存储和提取
2.  MySQL5.5.5版本以后默认使用InnoDB(支持事务)
3.  存储引擎是插件式的