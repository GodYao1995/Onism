[TOC]

# 跳跃表

1.  跳跃表是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的
2.  Redis使用跳跃表作为有序集合键的底层实现之一
3.  跳跃表的效率可以和平衡树相媲美，跳跃表的实现比平衡树要来得更为简单
4.  跳跃表中的节点按照分值大小进行排序，当分值相同时，节点按照成员对象的大小进行排序

## 跳跃表节点

### 定义

~~~c
typedef struct zskiplistNode {
    struct zskiplistNode *backward;    // 后退指针
    double score;  				       // 分值
    robj *obj;  					   // 成员对象
    struct zskiplistLevel {   		   // 层
        struct zskiplistNode *forward; // 前进指针
        unsigned int span;   		   // 跨度
    } level[];						   // 层是一个数组
} zskiplistNode;
~~~

### 说明

1.  后退指针，便于尾部往头部访问节点，每次只能一个

2.  分数和对象

3.  层是一个数组，数组中的结构包含结构

    *   前进指针
    *   跨度

4.  层的每一个结构成员在前进指针和跨度的作用下可以访问到所有的节点

5.  注意

    每次创建一个新跳跃表节点的时候，程序都根据幂次定律（越大的数出现的概率越小）随机生成一个介于1和32之间的值作为level数组的大小，这个大小就是层的“高度”，**所以每个跳跃节点的层高不定的**

## 跳跃表

### 定义

~~~c
typedef struct zskiplist {
    structz skiplistNode *header, *tail;  // 表头节点和表尾节点
    unsigned long length;   			  // 表中节点的数量
    int level;    						  // 表中层数最大的节点的层数
} zskiplist;
~~~

### 说明

1.  header和tail指向跳跃表的表头和表尾节点，通过这两个指针，程序定位表头节点和表尾节点的复杂度为O（1）
2.  用length属性来记录节点的数量，程序可以在O（1）复杂度内返回跳跃表的长度
3.  level属性则用于在O（1）复杂度内获取跳跃表中层高最大的那个节点的层数量，注意表头节点的层高并不计算在内

## 图示

![Redis跳表](images/Redis跳表.svg)

![Redis真实跳跃表](images/Redis真实跳跃表.svg)