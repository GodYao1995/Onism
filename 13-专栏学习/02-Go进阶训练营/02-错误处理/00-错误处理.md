[TOC]

### 错误处理最佳实践

#### panic实践

1. 程序启动，如果强依赖的服务出现故障，直接panic推出，给出提示
2. 程序启动，如果配置读取不符合，直接panic退出，给出提示

除了以上两种情况，其余情况都不应该直接panic，应该返回error进行判断

3. 程序入口，某些中间件需要recover预防panic退出整个程序
4. 避免野生的goroutine
    * 需要异步任务，尽可能使用异步的work，避免大量请求创建大量goroutine
    * 需要创建goroutine，应该使用统一带有recover的函数，避免野生goroutine造成主程序panic推出

~~~go
func Go(f func())  {
	go func() {
		defer func() {
			if err := recover(); err != nil {
				log.Printf("panic: %+v", err)
			}
		}()
		f()
	}()
}

~~~

#### error实践

1. error应该是函数最后一个返回值，当error!=nil 时，**其他的返回值均处于不可用状态**
2. error判断应该及时判断, 尽早返回，并且减少嵌套

~~~go
func Foo() error {
    f, err := os.Open("path")
    if err != nil {
        return err
    }
    .....
    return nil
}
~~~

3. **应用程序**中使用[github.com/pkg/errors](github.com/pkg/errors)处理错误(公共库不适用)
4. 在**应用程序**中出现错误时，使用 `errors.New` 或者 `errors.Errorf` 返回错误

~~~go
func (u *User) CheckUserName(name string) error {
    exist := u.repo.GetUserByName(name)
    if exist {
        return errors.Errorf("%s: 已经存在", name)
    }
    ...
    return nil
}
~~~

5. 如果是调用**应用程序的**其他函数出现错误，请直接返回，如果需要携带信息，请使用 `errors.WithMessage`

~~~go
func (u *User) CheckUserEmail(email string) error {
    err := u.otherFunc()
    if err != nil {
        return errors.WithMessage(err, "其他附加信息")
    }
    ...
    return nil
}
~~~

6. 如果是调用其他库（标准库、企业公共库、开源第三方库等）获取到错误时，请使用`errors.Wrap` 添加堆栈信息
    * 切记，不要每个地方都是用 `errors.Wrap` 只需要在错误第一次出现时进行 `errors.Wrap` 即可
    * 根据场景进行判断是否需要将其他库的原始错误吞掉，例如可以把 `repository` 层的数据库相关错误吞掉，返回业务错误码，避免后续我们分割微服务或者更换 `ORM` 库时需要去修改上层代码

~~~go
func Moo() error {
    err := json.Unmashal(&Struct, bytes)
    if err != nil {
        return errors.Wrap(err, "其他附加信息")
    }

    // ...
    return nil
}
~~~

7. **禁止**每个出错的地方都打日志，**只需要**在进程的最开始的地方使用 `%+v` 进行统一打印，例如 http/rpc 服务的中间件
8. 错误判断使用 `errors.Is` 进行比较

~~~go
func f() error {
    err := Read()
    if errors.Is(err, io.EOF){
    	return nil
    }
    // ...
    return nil
}
~~~

9. 错误类型判断，使用 `errors.As` 进行赋值

~~~go
func f() error {
    err := F1()

    var errF1 errorF1
    if errors.As(err, &errF1){
    	// ...
    }
    // ...
    return nil
}
~~~

10. 错误信息应当依据"排查问题时的需求而定"，快速定位问题
11. 对于业务错误可以建立统一管理字典 code: error， 并且需要建立清晰的文档
12. 不需要返回、或者被忽略的错误应当记录日志
13. 对于大量出现重复错误的地方，可以记录错误以及错误次数（避免日志被大量相同的错误淹没）
14. 类型相同的错误，应该采用相同的模式
15. 处理资源类错误，必须要defer清理句柄

#### panic or error？

1. panic问题
    * 只要有一个地方没处理好，就会导致程序异常退出
    * 如果用recover，那么频繁的panic-recover会有性能问题
    * panic后，处理逻辑交由外部程序，外部不一定能保证处理
2. 什么时候用panic
    * 真正意外的情况，不可恢复的程序错误(索引越界、栈溢出、不可恢复环境)
3. error好处
    * 考虑失败、面向故障编程
    * 及时处理错误、没有隐藏的控制流
    * 自己掌控error

#### error定义

1. 包级别错误变量

    > 在外部判定的时候一般使用等值判定或者使用 `errors.Is` 进行判断

~~~go
var EOF = errors.New("EOF")
~~~

2. error types

    > 可以包含更多的信息

~~~go
type ErrorString struct {
	s 	 string
    name string
    path string
}

func (e ErrorString) Error() string {
	return e.s
}

// New 创建一个自定义错误
func New(s string) error {
	return ErrorString{s: s}
}

func f() {
     switch err.(type) {
        case *ErrorString:
        // ...
        case others:
        // ...
    }
}
~~~

#### error优化

1. errWriter

    > 先暂存error，最后才判断

~~~go
type errWriter struct {
    w   io.Writer
    err error
}

func (ew *errWriter) write(buf []byte) {
    if ew.err != nil {
        return
    }
    _, ew.err = ew.w.Write(buf)
}

ew := &errWriter{w: fd}
ew.write(p0[a:b])
ew.write(p1[c:d])
ew.write(p2[e:f])

if ew.err != nil {
    return ew.err
}
~~~

2. 不要处处使用errors.Wrap