[TOC]

### 接口

接口是一种类型, 是对其他类型的行为的抽象与概括. (一组方法签名的集合)

接口类型不会和特定的实现细节绑定在一起, 

#### 定义

~~~go
type Notifier interface {
    Notify()
}
~~~

1.  接口一般以er结尾
2.  接口的定义是方法声明的的集合, 包括方法名, 参数列表和返回值列表
3.  接口可以嵌套「接口里可以有 方法描述 和 其他接口」
4.  接口的零值是nil

#### 类型实现

1.  接口的实现不依赖于接口定义本身, 接口的具体实现不需要显式说明
2.  被定义的行为不由接口实现, 通过方法定义的类型实现
3.  一个类型可以实现多个接口、接口之间是隔离的, 多个类型也可以同时实现一个接口

**类型T的方法集是接口类型X的方法集的超集, 那么类型T实现了接口类型X**

#### 接口运算

**接口变量绑定具体类型的实例的过程称为接口初始化** [类型实例赋值给接口变量]

**前提**  用户定义的类型[实体类型]实现了接口类型声明的方法集的超集

**原理**  接口变量被赋值后内存布局：两个字长度的数据结构

- [ ] 第一个字指向内部表的指针[存储值的类型信息以及值的方法集]
- [ ] 第二个指向所存储值的指针

**接口初始化**

1.  实例实现了接口
2.  实例赋值给对应的接口变量[进行静态类型检测]

**类型**

1.  接口被定义时, 其类型就已经被确定, 这叫接口的静态类型静态类型的本质是接口的方法签名, 如果两个接口的方法签名完全相同, 那么这两个接口在语义上完全等价, 并且可以进行相互的赋值
2.  接口被赋值绑定实例的类型, 此时称接口的类型是动态类型[接口可以绑定不同的类型]

**补充**

~~~go
var _ xxInterface = xxStruct   // 强制检测确保 xxStruct 实现 xxInterface
~~~

#### 方法集

方法集定义接口的接受规则, 定义了一组关联到给定类型的值或者指针的方法

| Method Receivers |  Values  |
| :--------------: | :------: |
|      (t T)       | T and *T |
|      (t *T)      |    *T    |

1.  如果接收者是值接收者, 那么类型的值或者指针都能实现对应的接口, 也就是能赋值给对应的接口变量
2.  如果接收者是指针接收者, 那么只有指向类型的指针才能实现对应的接口

**接口方法调用**

1.  接口方法调用的最终地址是在运行期决定的
2.  将具体类型变量赋值给接口初始化后, 会使用具体类型的方法指针初始化接口变量
3.  当使用接口变量调用方法时,  实际上是间接地调用实例的方法, 所以有一定的开销

#### 接口运算

**接口值**

一个接口的值（简称接口值）是由一个具体类型和具体类型的值两部分组成的,

1.  接口的动态类型
2.  接口的动态值

~~~go
type Notifier interface {
    Notify()
}
type User struct {
    Name string
    Email string
}
func main() {
    u := User{"liyao", "qq.com"}
    var n Notifier = &u
}
~~~

此时, 接口n的动态类型是*User, 动态值是&u

**类型断言**

类型推断可将接口变量还原为原始类型，或用来判断是否实现了某个更具体的接口类型

~~~go
接口变量.(类型或者接口类型)
~~~

**说明**

1.  必须是接口变量才可以类型断言
2.  断言的类型可以是结构类型或者接口类型
3.  断言不成功回panic

**目标**

1.  判断接口变量绑定的实例的类型是否是断言的类型, 如果断言true, v的类型就是TypeName, v值是i绑定实例的副本
2.  判断接口变量绑定的实例子是否同时实现了断言的接口, 如果断言true, v的类型就是Interface, v底层绑定的具体类型实例是i绑定实例值的副本
3.  断言安全写法如下, 不会panic

~~~go
if v, ok := i.(TypeName_or_Interface); ok {
    // code, 断言可以获取接口中具体类型的数据
}
~~~

**类型查询**

~~~go
switch v := i.(type) {
    case Type:
}
~~~

**目标**

1. 查询一个接口变量底层绑定的底层变量是什么
2. 查询一个接口变量绑定的底层变量是否还实现了其他的接口

**注意**

1.  fallthough不能在这里使用
2.  v值和类型断言的意义一样

#### 空接口

~~~go
interface{}
~~~

**定义**

1.  没有任何方法声明的接口成为空接口
2.  任何的类型都实现了空接口

**特点**

1.  由于所有的类型都实现了空接口, 那么任何类型的实例都可以赋值给空接口变量
2.  **空接口是interface类型, 不是任意类型**
3.  空接口不是真的空, 有动态类型和值, 以及空接口的实现不是简单的

**作用**

1.  空接口通常用来处理未知类型或者多种类型的数据
2.  空接口可以作为函数的参数

~~~go
func Foo(i interface{}) {}
~~~

#### 多态

代码可以根据不同类型的具体实现采取不同行为的能力

~~~go
type Notifier interface {
    Notify()
}
type User struct {
    Name string
    Email string
}
func (u *User) Notify() {}
type Admin struct {
    Name string
    Email string
}
func (a *Admin) Notify() {}
func SendNotification(n Notifier) {
    n.Notify()
}
func main() {
    u := User{"liyao", "qq.com"}
    a := Admin{"mike", "163.com"}
    SendNotification(&u)
    SendBotifycation(&a)
}
~~~

#### 最佳行为

1.  接口可以定义的小点
2.  接口可以嵌套, 大接口由小接口组成
3.  业务实现功能只依赖小的接口