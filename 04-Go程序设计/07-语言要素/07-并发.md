[TOC]



### Goroutine

#### 分析

1.  进程是包含了程序运行中需要用到和维护的各种资源容器

    包括但不限于内存地址空间、文件和设备句柄以及线程

2.  线程是操作系统最小的执行空间, 被操作系统调度来运行函数中写的代码

#### 协程

函数级别并发, 协程之间的切换代价远远小于线程的切换

#### 理解

1.  Go语言在语法和运行时直接对并发支持
2.  Go语言中并发指的是让某个函数独立于其他函数运行的能力
3.  操作系统在物理处理器上调度线程, Go语言在运行时会在逻辑处理器上调度g来运行
4.  每个逻辑处理器分别绑定到单个操作系统线程

#### 流程

1.  创建g, 分配到调度器的全局运行队列
2.  调度器将g分配给一个逻辑处理器, 放到逻辑处理器的本地队列
3.  遇到网络IO
    *   g会和逻辑处理器分离, 移到集成网络轮询器的运行时
    *   一旦轮询器指示网络可用, 那么g又会分配到逻辑处理器
4.  遇到系统阻塞调用
    *   当前的线程和脱离逻辑处理器, 继续阻塞, 等待系统返回
    *   当前的逻辑处理器会获得调度去创建的新的线程, 并绑定到一起
    *   被阻塞的线程执行完成并返回, 对应的g就会放回本地运行队列、线程也会保持好, 以便之后继续使用

#### 创建

>   1.  通过`go` 关键字来启动函数, 就可创建并发执⾏单元
>   2.  无需了解任何执⾏细节,调度器会自动将其安排到合适的线程上执行

~~~go
go func() {
    // code
}
~~~

1. 通过go关键字启动
2. 可以是匿名函数也可以是有名函数, 没有返回值
3. 非阻塞的, 不会等待
4. ""没有父子goroutine的概念, 都是平等的"
5. Go程序在执行时单独为main函数创建一个主goroutine, 遇到其他的再去创建

**说明**

1.  可以将main函数看成mian goroutine, 开启的其他的叫子goroutine

2.  注意：当main groutine退出, 其他的groutine也会退出

#### 并发控制

##### 同步

1.  等待

~~~go
func main() {
    var wg sync.WaitGroup
	wg.Add(1)
    go func() {
        defer wg.Done()
    }
	wg.Wait()
}
~~~

5.  原子函数: 能以很底层的加锁机制来同步控制访问整形变量和指针


~~~go
atomic.AddInt64(&counter, 1) // 整形加法
atomic.StoreInt64(&flag, 1)  // 安全写
atomic.LoadInt64(&flag)      // 安全读
~~~

6.  互斥锁

~~~go
var mutex sync.Mutex
func FooLock() {
    mutex.Lock()
    {
        // Lock code
    }
    mutex.UnLock()
}
~~~

**用等待加上互斥锁可以解决并发带来的共享数据安全的问题**

7.  snyc其他API: 提供了互斥锁、读写锁、条件变量等常见并发场景需要的API


~~~go
var once sync.Once
once.Do(func(){})           // Do方法的有效调用次数永远是1
var scene sync.Map          // 并发安全的Map
scene.Store("name","liyao")
scene.Load("name")	
~~~

##### 调度

运行时可能会创建很多线程，但任何时候仅有限的几个线程参与并发任务执行

1.  给可用的核心分配逻辑处理器

~~~go
runtime.GOMAXPROCS(1)               // 数量默认与处理器核数相等
runtime.GOMAXPROCS(runtime.NumCPU())// 参数小于1GOMAXPROCS仅返回当前设置值不做任何调整
~~~

2.  退出当前的线程, 并且放回队列, 退出之前会调用已经注册的defer, 不会产生panic

~~~go
runtime.Goexit()
~~~

3.  放弃当前调度, 放到队列中进行下一次调度

~~~go
runtime.Gosched()
~~~

#### CSP

>   CSP——通信顺序进程, 即是使用管道通信

##### channle

**含义**

Go中的数据类型, 通道, 遵循FIFO

**作用**

1.  g之间数据共享[可以共享内置类型、命名类型、结构类型、引用类型的值或者指针]
2.  g之间的同步

**特点**

1.  通过通信来共享
2.  模型简单
3.  有容量限制并且独立于处理g

**定义**

~~~go
make(chan Type)
make(chan Type, capacity)
~~~

**说明**

1.  使用make创建, chan关键字
2.  Type指的是类型
3.  capacity指的是通道容量, 无此参数表示无缓冲通道

**无缓冲**

1.  发送端g和接收端g必须同时准备好, 如果有一端g没有准备好, 会导致先执行的g阻塞等待
2.  无缓冲的通道操作的g一定是同步的

![channel](https://gitee.com/GodYao1995/resources/raw/master/images/channel.svg)

**有缓冲**

1.  能在其中中存储值的通道
2.  不强制要求接收端g和发送端g同时准备好, 无法保证g在同一时间交换数据, 但是可以解耦发送和接收操作
3.  通道为空, 接收端g操作就会阻塞
4.  通道为满, 发送端g操作就会阻塞

![有缓冲channel](https://gitee.com/GodYao1995/resources/raw/master/images/%E6%9C%89%E7%BC%93%E5%86%B2channel.svg)

**操作**

1.  通道操作符号   <-

~~~go
channel <- data  // 写入
<-channel        // 读取
~~~

2.  len函数获取通道数据个数, cap函数获取通道容量
3.  关闭通道 close
    *   写入完成可以关闭通道
    *   关闭后的通道无法再次关闭, 会panic
    *   关闭后无法再向其发送数据、但是能从中接受数据
    *   **从一个关闭而没有数据的通道中获取数据, 会返回通道类型的零值**

4.  ok模式

~~~go
value, ok := <-channel  // 用来检测通道是否被关闭
if !ok {} 
~~~

5.  for-range

~~~go
for data := range channel {}
// 会不断从信道接收值, 直到它被关闭
// 所以也需要自己在发送端手动关闭通道, 否则就会一直阻塞发生死锁
~~~

**注意**

**发送值进入通道是值的副本**

**单向通道**

默认定义的channel就是双向的, 单向channel, 不能做该端的相反操作

**定义**

1.  单向写

~~~go
var sendChannle chan<- Type   
sendChannel := make(chan<- Type)
~~~

2.  单向读

~~~go
var recvChannel <-chan Type
recvChannel := make(<-chan Type)
~~~

双向channel可以隐式转换为单向channel, 单向不能转双向

~~~go
var sendChannle chan<- Type
channel := make(chan Type)
sendChannel = channel
~~~

**参数**

1.  单向通道应用于函数或者方法的参数比较多
2.  channel传参数是传递引用 , 一般都是作为参数使用[限制], 对函数调用方的一种约束

~~~go
func send(in chan<- int) {
	in <- 69
}
func recv(out <-chan int) {
	data := <-out
	fmt.Println(data)
}
func main() {
	channel := make(chan int)
    // 必须有go程
	go func() {
		send(channel)
	}()
	recv(channel)
}
~~~

##### Select

**作用**

select为通道设计, 监听channel数据流动, 每个`case`表达式中都只能包含操作通道的表达式

**说明**

在一个select语句中, 会按顺序从上至下评估每一个发送和接收的语句【只扫描一次】

1.  **如果都阻塞了, 会等待直到其中一个可以处理**
2.  如果多个可以处理, 随机选择一个
3.  如果没有通道操作可以处理并且写了 `default` 语句, 它就会执行：`default` 永远是可运行的

~~~go
func main() {
	channel := make(chan int)
	quit := make(chan bool)
	// 写
	go func() {
		for i := 0; i < 5; i++ {
			channel <- i
			time.Sleep(time.Second)
		}
		close(channel)  // 发送完成关闭channel
		quit <- true    // 结束
		return
	}()
	// 读
	for {
        // 监听channel数据
		select {
		case data := <-channel:
			fmt.Println(data)
		case <-quit:
			//break // 只能跳出select
			return
        default:
			fmt.Println("wait data")
			time.Sleep(time.Second)
		}
	}
}
~~~