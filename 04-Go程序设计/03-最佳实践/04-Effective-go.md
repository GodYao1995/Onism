[TOC]



## Effective-Go

### 格式化

~~~bash
go fmt
~~~

1.  缩进 默认使用tab
2.  行长
3.  空格
4.  括号

### 注释

~~~go
// 单行注释
/*
	多行注释
*/
~~~

1.  单行更为常用, 而块注释则主要用作包的注释
2.  每个包都应包含一段**包注释**, 即放置在包子句前的一个块注释

### 命名

**包**

1.  可见行【首字母大写其他的包可见, 小写本包内可见】
2.  名称应该简洁明了易于理解. 按照惯例, 包应当以小写的单个单词来命名, 且不应使用下划线或驼峰记法

**接口**

只包含一个方法的接口应当以该方法的名称加上-er后缀来命名

**驼峰命名**

Go中约定使用驼峰记法

### 分号

1.  Go的正式语法使用分号来结束语句, 词法分析器会使用一条简单的规则来自动插入分号, 源码中不用分号

2.  不能将一个控制结构（`if`、`for`、`switch` 或 `select`）的左大括号放在下一行

### 控制结构

if

1.  基本

~~~go
if cond {
    // code
}
~~~

2.  初始化条件

~~~go
// 注意局部变量了
if err := file.Chmod(0664); err != nil {
	log.Print(err)
	return err
}
~~~

for

1.  基本

~~~go
// 注意 for中的局部变量
for initVar; cond; ins {
    //
}
~~~

2.  类似while

~~~go
for cond {
    
}
~~~

3.  死循环

~~~go
for {
    
}
~~~

4.  range

    遍历数组、切片、字符串或者映射, 或从信道中读取消息,  `range` 子句能够帮你轻松实现循环

~~~go
for index, value := range collection {
    
}
~~~

5.  switch

    case 语句会自上而下逐一进行求值直到匹配为止. 若 switch 后面没有表达式, 它将匹配 true

```go
func unhex(c byte) byte {
	switch {
	case '0' <= c && c <= '9':
		return c - '0'
	case 'a' <= c && c <= 'f':
		return c - 'a' + 10
	case 'A' <= c && c <= 'F':
		return c - 'A' + 10
	}
	return 0
}
```

6.  类型选择

     类型选择 通过圆括号中的关键字 `type` 使用类型断言语法

~~~go
var t interface{}
t = functionOfSomeType()  // 注意断言的一定是接口类型
switch t := t.(type) {
default:
	fmt.Printf("unexpected type %T", t)       // %T 输出 t 是什么类型
case bool:
	fmt.Printf("boolean %t\n", t)             // t 是 bool 类型
case int:
	fmt.Printf("integer %d\n", t)             // t 是 int 类型
case *bool:
	fmt.Printf("pointer to boolean %t\n", *t) // t 是 *bool 类型
case *int:
	fmt.Printf("pointer to integer %d\n", *t) // t 是 *int 类型
}
~~~

### 函数

**多值返回**

1.  普通返回

~~~go
func Foo(s string) (string error) {
    //
}
~~~

2.  命名返回

~~~go
func Foo(s string) (str string err error) {
    //
}
~~~

**Defer**

1.  Go的 `defer` 语句用于预设一个函数调用，该函数会在执行 `defer` 的函数返回之前立即执行

2.  被推迟的函数按照后进先出（LIFO）的顺序执行

### 数据

**new**

1.  它不会**初始化**内存, 只会将内存**置零**
2.  `new(T)` 会为类型为 `T` 的新项==分配已置零的内存空间,  并返回它的地址==. , 它返回一个指针,  该指针指向新分配的, 类型为 `T` 的零值
3.  new用于值类型的内存分配【数字/字符串/布尔/数组/结构体】

**make**

1.  它只用于创建切片、映射和信道, 并返回类型为 `T`（而非 `*T`）的一个**已初始化** （而非**置零**）的值

2.  出现这种用差异的原因在于, 这三种类型本质上为引用数据类型, 它们在使用前必须初始化
3.  对于切片、映射和信道, `make` 用于初始化其内部的数据结构并准备好将要使用的值

### 数组

1.  数组是值. 将一个数组赋予另一个数组会复制其所有元素

2.  特别地, 若将某个数组传入某个函数, 它将接收到该数组的一份**副本**而非指针

3.  数组的大小是其类型的一部分. 类型 `[10]int` 和 `[20]int` 是不同的
4.  数组为值的属性很有用, 但代价高昂；若你想要C那样的行为和效率, 你可以传递一个指向该数组的指针

### 切片

1.  切片保存了对底层数组的引用, 若你将某个切片赋予另一个切片, 它们会引用同一个数组
2.  若某个函数将一个切片作为参数传入, 则它对该切片元素的修改对调用者而言同样可见,  这可以理解为传递了底层数组的指针
3.  只要切片不超出底层数组的限制, 它的长度就是可变的, 只需将它赋予其自身的切片即可
4.   切片的**容量**可通过内建函数 `cap` 获得, 它将给出该切片可取得的最大长度

### 映射

1.  其键可以是任何相等性操作符支持的类型
2.  值可以是任意的类型

### 常量

1.  Go中的常量就是不变量. 它们在编译时创建, 即便它们可能是函数中定义的局部变量
2.  常量只能是数字、字符（符文）、字符串或布尔值

### init函数

1.  每个源文件都可以通过定义自己的无参数 `init` 函数来设置一些必要的状态
2.   只有该包中的所有变量声明都通过它们的初始化器求值后 `init` 才会被调用,  而那些 `init` 只有在所有已导入的包都被初始化后才会被求值

### 方法

### 指针vs值作为接受者

以指针或值为接收者的区别在于：值方法可通过指针和值调用,  而指针方法只能通过指针来调用

### 接口与其他类型

接口

Go中的接口为指定对象的行为提供了一种方法：如果某样东西可以完成**这个**,  那么它就可以用在**这里**

接口断言

~~~go
type Stringer interface {
	String() string
}
var value interface{} // 调用者提供的值
switch str := value.(type) {
case string:
	return str
case Stringer:
	return str.String()
}
~~~

接口检查

```go
if _, ok := val.(json.Marshaler); ok {
	fmt.Printf("value %v of type %T implements json.Marshaler\n", val, val)
}
```

### 空白标示

1.  空白标识符可被赋予或声明为任何类型的任何值, 而其值会被无害地丢弃
2.  未使用的导入和变量可以使用空白标识符

~~~go
var _, ok = m["key"] {
    // code
}
~~~

### 并发

**goroutine**

1.  它是与其它Go程并发运行在同一地址空间的函数

2.  它是轻量级的,  所有消耗几乎就只有栈空间的分配

    而且栈最开始是非常小的, 所以它们很廉价,  仅在需要时才会随着堆空间的分配（和释放）而变化

3.  Go程在多线程操作系统上可实现多路复用, 因此若一个线程阻塞,  那么其它的线程就会运行

**通道**

1.   `make` 来分配内存

~~~go
ci := make(chan int)            // 整数类型的无缓冲信道
cj := make(chan int, 0)         // 整数类型的无缓冲信道
cs := make(chan *os.File, 100)  // 指向文件指针的带缓冲信道
~~~

2.  无缓冲信道在通信时会同步交换数据, 它能确保（两个Go程的）计算处于确定状态

3.  若信道是带缓冲的, 则发送者仅在值被复制到缓冲区前阻塞

    若缓冲区已满, 发送者会一直等待直到某个接收者取出一个值为止

### 错误

1.  error

按照约定, 错误的类型通常为 `error`, 这是一个内建的简单接口. 

```go
type error interface {
	Error() string
}
```

2.  panic

~~~go
panic("something wrong")
~~~

3.  recover

    当 `panic` 被调用后（包括不明确的运行时错误, 例如切片检索越界或类型断言失败）,  程序将立刻终止当前函数的执行, 并开始回溯Go程的栈, 运行任何被推迟的函数.  若回溯到达Go程栈的顶端, 程序就会终止. 不过我们可以用内建的 `recover` 函数来重新或来取回Go程的控制权限并使其恢复正常执行

~~~go
defer func() {
    if err := recover(); err != nil {
        fmt.Println(err)
    }    
}()
~~~