[TOC]

# Advice

## 箴言

1.  通过通信共享内存
2.  并发不是并行
3.  通道编排: 互斥体序列化
4.  **接口越大，抽象越弱**
5.  **零值有用**
6.  **interface{} 就是 interface{}**
7.  gofmt
8.  反射永远不清晰
9.  错误就是价值观
10.  **不要只检查错误，还要优雅的处理**
11.  **设计架构、命名组件、记录细节**
12.  文档供用户使用
13.  **不要panic**

## 禅道

1.  **package实现单一目的**
2.  **显示处理错误**
3.  **尽早返回，避免深嵌套**
4.  让调用者选择并发
5.  **启动g，需要知道何时停止**
6.  避免package级别状态编写测试以锁定 package API 的行为
7.  编写benchmark测试
8.  节约内存
9.  可维护性
10.  **大道至简**

## 代码

1.  go fmt
2.  多个if可以使用switch代替
3.  chan struct{} 传递信号
4.  30 * time.Second 比 time.Duration(30) * time.Second 好
5.  用 var foo time.Dutation 比 var fooMillis int64 好
6.  总是把for-select换成一个函数
7.  **分组定义const和var**
8.  _ 表示不需要的参数
9.  不要panic
10.  每个阻塞或者IO函数都是可取消或者可超时的
11.  for-range来迭代集合，复制的集合去迭代
12.  **多行字符串使用反引号**
13.  函数的同类型参数类型放最后
14.  slice的零值是nil
15.  **ok模式读取map的值**
16.  强制显式按照成员名字初始化结构体

~~~go
type Point struct {
	X, Y float64
	_    struct{} // to prevent unkeyed literals
}
// p := Point{X:13.5, Y:213.3}
~~~

17.  防止结构体比较

~~~go
 type Point struct {
    _ [0]func() // unexported, zero-width non-comparable field
    X, Y float64
  }
~~~

18.  移动defer到顶部

## 并发

1.  以线程安全创建一些东西最好选择是 sync.Once
2.  永远不要使用select{}
3.  当你需要一个自定义类型的 atomic 值时，可以使用 [atomic.Value](https://godoc.org/sync/atomic#Value)

## 性能

1.  **不要省略defer**
2.  关闭http body 【defer r.Body.Close()】
3.  请勿在你的热路径中过度使用 `fmt.Sprintf`. 由于维护接口的缓冲池和动态调度，它是很昂贵的。
    -   如果你正在使用 `fmt.Sprintf("%s%s", var1, var2)`, 考虑使用简单的字符串连接。
    -   如果你正在使用 `fmt.Sprintf("%x", var)`, 考虑使用 `hex.EncodeToString` or `strconv.FormatInt(var, 16)`
4.  `regexp.MustCompile` 比 `regexp.Compile` 更好
5.  **不要在循环中使用 defer，否则会导致内存泄露**
6.  不要忘记停止 ticker, 除非你需要泄露 channel
7.  **`sync.Map` 不是万能的，没有很强的理由就不要使用它**
8.  在 `sync.Pool` 中分配内存存储非指针数据
9.  清空map【循环删除、make一个新的赋值】

## 测试

1.  测试名称 `package_test` 比 `package` 要好
2.  在编译期检查接口的实现

~~~go
type Point struct {
	X, Y float64
	_    struct{} // to prevent unkeyed literals
}
type Modifier interface {
	Foo()
}
func (p *Point) Foo()  {

}
var _ Modifier = (*Point)(nil)  // 骚操作
~~~

3.  匿名结构体

~~~go
 type hits struct {
     sync.Mutex
     n int
 }
func (h *hits) Modify() {
    h.Lock()  // 匿名结构体提升了方法和属成员
    n++
    h.Unlock()
}
~~~



## 编程指南

1.  生产环境避免panic
2.  避免可变全局变量
3.  类型转换strconv代替fmt
4.  避免字符串转字节
5.  初始化Map指定容量
6.  类型断言采用 ok模式，否则容易panic
7.  枚举从1开始，也有需求从0开始
8.  channel容量为1或者无缓冲
9.  defer清理资源
10.  注意Slice和Map引用类型作为参数共享
11.  零值得Mutex是有效的
12.  结构体匿名成员不公开，如要公开需要声明
13.  不要使用指针指向接口
14.  接口调用方法要注意接收者
15.  错误处理
     *   简单错误信息errors.New()
     *   定制Error()
     *   fmt.Errorf()

16.  测试数据：结构体多组数据