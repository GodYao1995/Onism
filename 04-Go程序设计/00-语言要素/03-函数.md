[TOC]

### 函数

1. 函数是一种类型
2. 可以作为变量的值
3. 可以作为参数和返回值
4. 支持多值返回
5. 支持闭包
6. 支持可变参数

#### 定义

1. 声明func
2. 函数名
3. 参数列表
4. 返回值列表
5. 函数体
6. return

~~~go
func Foo(a, b int) int {
    num := a + b
    return
}
func Foo(a int, b int) (num int) {
    num = a + b
    return
}
// 参数简写, 一般来说如果有错误处理都返回最后一个参数
func Bar(a, b int) (num int, err error) {
    num = a + b
    return num, nil
}
~~~

注意

1. 不支持默认参数
2. 不支持函数重载
3. 严格意义上来说, **不支持命名函数的嵌套**
4. 函数的调用直接通过()操作符, 或者go关键字调用
5. 返回值列表声明后不需要在函数中再次声明返回值

#### 调用

~~~go
foo(params)
~~~

#### 参数

**性质**

>   1. 函数的参数传递都是值传递
>   2. 数字、字符串、布尔值、数组、结构体是值传递
>   3. slice、map、channel由于是引用类型所以传递的是引用的拷贝[值传递]

**不定参数**

3. 必须作为最后一个参数
2. 在函数体中相当于切片

~~~go
func sum(items ...int) (sum int) {
    for _, item := range items {
        sum += item
    }
    return
}
~~~

#### 签名

1. 函数类型又叫做函数的签名
2. 若两个函数的形式参列表和返回值列表一致, 形参名可以不同, 称两个函数的类型相同

#### 类型

2.  函数是一种引用类型, 未初始化的函数是nil
3.  函数的类型[去掉函数名、参数名、{}]

 ~~~go
func(int int)
func(int int) int
 ~~~

#### 匿名

>   1.  匿名函数配合 `go` 关键字来作为 goroutine 使用
>   2.  匿名函数同样被称之为闭包: 它们被允许调用定义在其它环境下的变量
>       *   一个闭包继承了函数所声明时的作用域.  
>       *   这种状态（作用域内的变量）都被共享到闭包的环境中, 因此这些变量可以在闭包中被操作, 直到被销毁

1.  直接定义匿名函数执行

~~~go
func (a ,b int) {
    return a + b
}(10, 20)
~~~

2.  变量接收

~~~go
var f func(int, int) int
f = func (a, b int) int{
    return a + b
}
f(1, 2)
~~~

#### 返回值

>   1.  关键字`return`
>   2.  函数一旦遇到return就停止
>   3.  函数不是一定需要return, 没有的话函数也会结束

1.  返回值类型

~~~go
func add(a, b int) int {
    return a + b
}
~~~

4.  多个返回值

~~~go
func eval(a, b int, op string) (int, error) {}
~~~

5.  返回值变量定义

~~~go
// 尽量使用命名返回值：会使代码更清晰、更简短, 同时更加容易读懂
func twoF(a, b int) (sum int, sub int) {
    sum = a + b
    sub = a - b
   	// 对于指定了返回的变量名, return 后面的值 可以不写, 这种方式比较好
    return  
}
~~~

6.  返回值丢弃

~~~go
_, sub := twoF(20, 10) 
~~~

#### 作用域

1.  局部变量
    *   函数内部定义的变量
    *   for/if语句中定义的变量属于局部变量
    *   大括号中定义的变量

2.  全局作用域
    *   函数外部的变量[不能和其他文件中的变量重名]
    *   可以在函数内部修改全局变量[会影响其他使用全局变量的地方]

#### 内置

|  函数   |         意义         |    注意     |
| :-----: | :------------------: | :---------: |
|   len   |     获取集合长度     |     无      |
|   cap   |     获取切片容量     |     无      |
|  copy   | 拷贝切片到另一个切片 |     无      |
| append  |       扩容切片       | 返回新切片  |
|   new   |      创建值类型      |  返回地址   |
|  make   |     创建引用类型     |  返回引用   |
|  panic  |       终止程序       |     无      |
| recover |   恢复panic的程序    | defer中使用 |
|  close  |       关闭通道       |     无      |

#### 闭包

闭包是由函数及其相关引用环境组合而成的实体,

>   1.  一般通过在匿名函数中引用外部函数的变量或全局变量构成
>
>   2.  如果函数返回的闭包引用了该函数的局部变量[参数或者局部变量]

多次调用该函数,返回的多个闭包所引用的外部变量是多个副本,每次调用函数都会为局部变量分配内存

用一个闭包函数多次,如果该闭包修改了其引用的外部变量,则每一次调用都会对该外部的变量都有影响

~~~go
package main

import "fmt"

func main() {
	f := Foo(0)
	fmt.Println(f()) // 1
	fmt.Println(f()) // 2
	fmt.Println(f()) // 3
	g := Foo(0)
	fmt.Println(g()) // 1
	fmt.Println(g()) // 2
	fmt.Println(g()) // 3
}
func Foo(a int) func() int {
	return func() int {
		a = a + 1  // 引用了外部函数的参数 
		return a
	}
}
~~~

说明

1. 使用闭包是为了减少全局变量, 在函数的调用中隐式传递共享变量
2. 但是闭包不够直接, 尽量少的使用, 闭包不是不可缺少的

**默认参数**

~~~go
type Queue struct {
	Name     string
	MaxLimit int
	// monitor
	MonitorInterval int
}

type QueueOption func(*Queue)

func WithMaxLimit(max int) QueueOption {
	return func(q *Queue) {
		q.MaxLimit = max
	}
}

func WithMonitorInterval(seconds int) QueueOption {
	return func(q *Queue) {
		q.MonitorInterval = seconds
	}
}
func NewQueue(name string, options ...QueueOption) *Queue {
	queue := &Queue{name, 10, 5} // 默认参数
	for _, o := range options {
		o(queue)
	}
	return queue
}
~~~
