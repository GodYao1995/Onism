[TOC]

### 结构类型

>   Go 通过类型别名和结构体的形式支持用户自定义类型, 或者叫定制类型. 

#### 特点

1.  一个带属性的结构体试图表示一个现实世界中的实体
2.  由一系列固定且唯一成员构成
3.  成员可以是Go的类型，并且存储空间是连续的，成员按照声明的顺序存放
4.  通过点操作符操作成员
5.  同一结构类型的实例之间是可以比较的，不过前提是成员也必须可以比较

#### 定义[实体]

##### 定义

1.  type 关键字
2.  struct 关键字

```go
type User struct { 		// 类型定义
	ID    int           // 标识符 类型  
	Name  string        // 结构体成员变量, 在内存中按照定义时的格式排列
	Age   int
}
type User struct {
    Name string
    Age  uint8
    _ struct{}  		// 声明结构体时, 强制使用一一对应的方式
}
```

##### 可见性

1.  结构体中字段大写开头表示可公开访问[在需要时大写，不需要时小写，按需操作]
2.  小写表示私有（仅在定义当前结构体的包中可访问）

##### 操作

1.  声明

    声明的结构体成员默认是所对应数据的零值


```go
var u User
u := new(User) // 等同于 u := &User{}
```

2.  字面量初始化

```go
u1 := User{3, "jack", 44} 
u2 := User{ID: 2, Name: "bob", Age: 30} 
```

4.  工厂函数

~~~go
func NewUser(name string, age int) *User {
    return &User{
        Name : name,
        Age: age,
    }
}
~~~

5.  空结构体

~~~go
var u = User{}
// 空结构体类型变量不占内存空间，内存地址相同，建议用于在通道里传递信号
// 当我们需要使用结构体而又不需要具体属性时可以使用它
// unsafe.Sizeof(u) 内存占用大小为0
~~~

6.  函数参数

>   1.  通常我们使用结构体指针的方式传递参数
>   2.  结构体指针可以在函数中直接点操作成员，而不必要解引用

#### 方法[行为]

**特点**

结构类型的方法是需要一个接受者

~~~go
type User struct {
	ID   int
	Name string
	Age  int
}
func (u User) ShowID() {
	fmt.Println(u.ID)
}
func (u *User) ShowName() {
    fmt.Println(u.Name)
}
func main() {
	u1 := User{ID: 1, Name: "jack", Age: 25}
	u2 := &User{ID: 2, Name: "liyao", Age: 25}
	u1.ShowID()
	u2.ShowID()
	u1.ShowName()
	u2.ShowName()
}
~~~

##### 值接收者

1.  结构体类型的值调用, 调用者会使用这个值的副本来执行
3.  结构体指针调用 [Go的编译器会将指针解引用以符合值接收者的要求]

##### 指针接收者

1.  结构体指针调用, 方法会共享接收者所指向的值
2.  结构体值调用[Go编译器会取结构体的指针，以符合指针接收者的要求]

##### 总结

1.  不管结构体的接收者是值接收还是指针接收，允许值实例和指针实例来调用方法
2.  创建一个新值就用值接收，修改当前值那么就用指针接收
3.  通常情况下，大部分的方法都是指针接收，特别是接收者是结构体的情况

#### 组合[内嵌、匿名]

##### 特点

1.  组合也可以称为嵌入类型
2.  通过组合[嵌入]来对结构体扩展
3.  通过合理设置同名成员来进行屏蔽

~~~go
type User struct {
	Name string
	Age int
	Contact struct{
		Address string
		Phone int
        Email string
	}
}
func (u *User) Notify() {}
type Admin struct {
    User
    Level string
}
~~~

**注意**

1.  嵌入一个类型只需要声明类型的名字[简单的称内部类型和外部类型，相对而言]
2.  **内部类型的成员和方法都会被提升**[外部类型可以访问]
3.  **内部实现的接口也会提升到外部**[外部类型也同样实现了这个接口]
4.  **如果外部类型实现了同名的成员\方法\接口,那么就会屏蔽内部类型的同名成员\方法\接口**

##### 总结

1.  类型组合是**非侵入式**的, 它不会破坏类型的封装或加重类型之间的耦合
2.  通过嵌入字段的方式把一个类型的属性和能力"嫁接"给另一个类型
    *   可以获取嵌入结构体的字段的属性
    *   可以调用嵌入结构体的方法
3.  组合有**屏蔽效应**[嵌入字段有哪里不合心意, 我们还可以用"包装"或"屏蔽"的方式去调整和优化]

**说明** 有名结构体嵌入的形式叫组合，访问的时候需要加上名称