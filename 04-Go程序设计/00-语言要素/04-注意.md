[TOC]

### 注意点

#### Package

##### main

1. 程序必须包含main 包,定义了一个独立可执行的程序，而不是一个库
2. main包中必须由main入口函数，并且main函数无参数和返回值

##### 导入

~~~go
import "fmt"
import p "fmt" // 别名
import _ "fmt" // 导入不使用, 会执行init、如果存在
import . "fmt" // 将fmt中的名字全部导入当前环境
~~~

##### 权限

1. 首字母大写公开权限，包外可用
2. 首字母小写隐藏权限，包内可用

##### init

>   1.  无参数、无返回值、在main函数之前执行
>   2.  初始化总是以单线程执行, 并且按照包的依赖关系顺序执行
>   3.  每个文件只能有一个init，并且不能手动调用

~~~go
func init() {
   
}
~~~

#### Pointer

>   1.  指针是一种直接存储了变量的内存地址的**数据类型**
>   2.  Go的指针不支持运算
>   3.  将一个变量赋值给指针，实际上是将变量的地址赋值给了指针，通过这个指针就可以找到这个变量

##### 操作

1. 取地址

```go
 var a int = 10
 var pa *int = &a  
```

2. 指针变量

```go
 var p *T  // 类型 `*T` 是指向 `T` 类型值的指针. 其零值为 `nil` 需要初始化才能使用
 var p *int
```

3. *解引用

```go
 var a int = 10
 var p *int = &a
 *p = 20     
```

##### 传参

>   1.  指针传递是很廉价的, 只占用 32位或64位个字节. 使用指针会减少内存占用和提高效率
>   2.  对于map slice chan引用类型, 其本身就是引用, 所以传递的时候就是传递引用的拷贝
>   3.  对于结构体是值类型通常我们也是传递结构体的指针

#### 初始化

##### new

> 初始化简单类型{数字类型、布尔类型、字符串类型、数组、结构体} 返回地址

##### make

> 初始化引用类型{切片、映射、通道} 返回类型引用

#### defer

> 1.  延迟函数的在主函数结束的时候调用
> 2.  多个defer会压栈，先进后出执行

注册多个延迟调用，并且多个调用的顺序是FIFO，常用于一些资源的回收以及释放

1.  打开文件/关闭文件
2.  加锁/释放锁
3.  打开连接/关闭连接

情况1: 延迟函数的参数

1.  延迟函数的参数在遇见defer的时候就已经确定

  2.  意思是遇见defer的延迟调用函数，会保存当前延迟函数状态

~~~go
func DeferParam() {
	i := 10
	defer fmt.Println(i)  // 10
	i++
}
~~~

情况2: 多个defer压栈执行

~~~go
func Defers() {
    // 3 2 1
	defer fmt.Println(1)
	defer fmt.Println(2)
	defer fmt.Println(3)
}
~~~

情况3: defer遇见panic

1.  遇到panic后，后面不在执行
2.  然后会执行已经注册的全部defer，并且将异常往回传递，直到异常被捕获

~~~go
package main
func f1() {
	defer println("f1-begin")
	f2()
	defer println("f1-end")
}
func f2() {
	defer println("f2-begin")
	f3()
	defer println("f2-end")
}
func f3() {
	defer println("f3-begin")
	panic(0)   
	defer println("f3-end")
}
func main() {
	f1()
}
~~~

3.  如果defer中也有panic，那么defer中的panic会覆盖main中的Panic

~~~go
func main() {
	defer func() {
        // 只有最后一个panic会被捕获
		if err := recover(); err != nil {
			fmt.Println(err)
		} else {
			fmt.Println("fatal")
		}
	}()
	defer func() {
		panic("defer panic") // defer panic 将main panic覆盖
	}()
	panic("main panic")
}
~~~

情况4: 异常捕获

~~~go
func RecoverPanic() {
	if err := recover(); err != nil {
		fmt.Println(err)
	}
}
func main() {
	defer RecoverPanic()
	panic("recover panic")
}
~~~

情况5: defer影响有名函数的返回值

1.  修改返回值
    *   return的操作不是原子操作，只是代理汇编的ret操作，即将跳转程序执行
    *   先将值压栈作为返回值
    *   然后执行跳转【defer的执行时机正是在跳转之前，所有有机会操作有名的返回值】

~~~go
func foo() (ret int) {
    defer func() {
        ret++
    }()
    return 0
}
// ret = 1
// ret = 0
// ret++
// return
~~~

2.  无法操作匿名的返回值

~~~go
func foo() int { //  还是返回1
    var i int
    defer func() {
        i++
    }()
    return 1
}
func foo() int { //  还是返回1
    var i int
    defer func() {
        i++
    }()
    return i
}
// retValue = i
// i++
// return retValue
~~~

3.  测试

~~~go
func DeferReturn() (t int) { //1: 初始值为0  3: 被修改为2
	defer func(i int) {
		fmt.Println(i)      // i = 0
		fmt.Println(t)  	// t = 2
    }(t) 					// 2: 出现defer的时候参数就已经确定 t = 0 然后 i = 0
	t = 1
	return 2  			    // 3 t= 2
}
~~~
