

[TOC]

### 容器

#### 数组

##### 定义

>   1.  数组是具有相同 **唯一类型** 的长度固定的数据项序列
>   2.  Go 语言中的数组是一种 **值类型**

##### 特点

1.  类型相同的元素成员 [可以是Go的任何类型]
2.  内存连续
3.  长度固定
4.  访问速度快

##### 声明

>   1.  类型以及数组长度必须确定
>   2.  默认初始化位成员类型的零值

~~~go
var array [5]int 
~~~

##### 初始化

1.  数组字面量

~~~go
array := [3]int{1, 2, 3}
~~~

2.  自动计算长度

~~~go
array := [...]int{1, 2, 3}
~~~

3.  指定位置赋值

~~~go
array := [5]int{1: 2, 2: 3, 4: 4}  // 位置没有初始化默认零值
~~~

4.  new

>   new返回指针, 不会进行初始化 

~~~go
p := new([3]int)  
~~~

##### 使用

>   1.  索引操作
>   2.  切片获取
>   3.  遍历元素


~~~go
first := arr[0]
slice := arr[1:5]
for i, v := range arr {}
~~~

##### 多维

~~~go
array := [m][n]int{}
array := [2][3]int{[3]int{1, 2, 3}, [3]int{4, 5, 6}} 
~~~

#### 切片

##### 特点

1.  动态增长
2.  切片是一种数据结构、切片是对数组一个连续片段的引用

##### 原理

>   切片不是一个数组的指针, 是一种复杂结构体, 由以下三部分组成
>
>   1.  指针指向底层的数组
>   2.  切片访问元素的个数
>   3.  切片允许增长的个数, 也就是容量

~~~go
type slice struct {
	arrary = unsafe.Pointer		//指向底层数组的指针
	len int						//切片元素数量
	cap int						//底层数组的容量
}
~~~

##### 创建

1.  切片字面量


~~~go
s := []int{1, 2, 3} 	    // 直接就指定了长度和容量, 如果扩容就会直接生成新的底层数组
~~~

2.  make函数

>   make会默认初始化len的类型零值

~~~go
s := make([]int, len)      // 未指定容量那么容量就是长度
s := make([]int, len, cap) // 指定切片的长度, 和容量 
~~~

3.  从数组创建

~~~go
s := array[1:3]  		   // 左闭右开
~~~

>   1.  不允许创建容量小于长度的切片
>   2.  分别指定长度容量时, 容量指的是底层数组的长度, 但是初始化后并不能访问所有的数组元素
>   3.  不可越界访问
>   4.  切片只能和nil比较,  但是可以使用reflect.DeepEqual来比较两个切片"是否相同"

##### 注意

1.  nil切片

>   可以使用append操作, 此时没有底层数组

~~~go
var s []int
s = append(s, 1)
~~~

2.  空切片

~~~go
s := []int{}      // 不建议
~~~

##### 使用

>   1.  索引操作
>   2.  len计算切片的长度, cap计算容量
>   3.  range遍历

~~~go
for k, v := range s {
    // range 会复制切片的成员而不是返回对该元素的引用
}
~~~

4.  通过切片创建切片

~~~go
s := []int{1, 2, 3, 4, 5}  // k = 5
ns := s[i:j]   
ns := s[:n] 
ns := s[:]
~~~

**说明** 

如何计算新切片的长度和容量

~~~bash
length =  j - i
cap = k - i   
~~~

**注意**

**通过这种方式创建的切片, 切片之间是共享底层数组的**

5.  拷贝

~~~go
copy(s, ns)
~~~

7.  其他

~~~go
s = append(s[:index], s[index+1:]...)
~~~

**注意**

1.  要注意创建切片是多个切片共享底层数组的情况
2.  如果要避免这种情况, 可以在创建切片的时候使长度等于容量, 扩容的时候就会创建新的底层数组

#### 映射

>   数据结构, 用来存储键值对的**无序集合**

##### 特点

1.  key是唯一的
2.  value可以是任意类型
3.  存取高效

**说明**

1.  key不可以是Func、Map、和Slice
2.  Bool、Int、Float、Complex、String、Pointer、channel等都可以做key

##### 创建

>   由定义的规则可以看出, 所有的key类型必须一致, 值类型必须一致, 这也是Map的限制

1.  字面量

~~~go
// 注意每个键值对后面必须要有一个逗号, 除非括号紧跟在value的后面
m := map[string]string{
    "name": "li_yao",
    "age": "18",  
}
~~~

2.  make


~~~go
m := make(map[string]int)     // empty 长度是0, 可以读写, 常用
m := make(map[string]int, 10) // 可以指定长度
~~~

**注意** 

>   Map必须初始化, nil映射不能存储键值对

##### 使用

1.  通过键

~~~go
v, ok := m["key"]     // 访问不存在的key不会报错
~~~

2.  赋值

~~~go
m["key"] = "value"    // 如果不存在就会添加, Map也是动态增长的
~~~

3.  遍历

~~~go
for k, v := range m {
    fmt.Println(k, v) // 返回的是键值对
}
~~~

5.  删除

~~~go
delete(m, "key")      // 是操作安全的, 不报错并且无返回值
~~~

6.  判断并获取value

~~~go
if v, ok := m["length"]; ok {} 
~~~

7.  问题

>   Map不是并发安全的