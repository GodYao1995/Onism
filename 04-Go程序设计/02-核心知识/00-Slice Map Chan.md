[TOC]

### Map

> 映射

#### Hash

##### 定义

> 1. 通过Key访问Value的数据结构
> 2. Hash函数将key转化为数组的索引，然后将Value存储在对应索引位置

~~~
hash(key) ==> (index) ==> value 
~~~

##### 问题

###### Hash冲突

不同的Key可能会生产相同的Hash值，所以一般通过拉链法，将冲突的Key对应的Value加入到统一链表中

###### 空间浪费

不同Key生成的Hash后，索引值差距较大

###### 扩容

当默认数组空间被填满后，如何扩容

#### Map

##### 核心结构

~~~go
type hmap struct {
    // Key-Value个数
	count     int 
	flags     uint8
    // log_2 of # of buckets (can hold up to loadFactor * 2^B items)
	B         uint8 
    // approximate number of overflow buckets; see incrnoverflow for details
	noverflow uint16 
    // hash seed
	hash0     uint32 
	// array of 2^B Buckets. may be nil if count==0. 底层的buckets指针
	buckets    unsafe.Pointer
    // previous bucket array of half the size, non-nil only when growing
	oldbuckets unsafe.Pointer 
    // progress counter for evacuation (buckets less than this have been evacuated)
	nevacuate  uintptr        
	// optional fields 可选 溢出的
	extra *mapextra 
}
~~~

##### 图示

![Map (1)](https://gitee.com/GodYao1995/resources/raw/master/images/Map%20(1).svg)

##### 流程

~~~go
m := make(map[string]int, 16)
~~~

##### 核心函数

> runtime.makemap()

~~~go
// makemap implements Go map creation for make(map[k]v, hint).
func makemap(t *maptype, hint int, h *hmap) *hmap {
	mem, overflow := math.MulUintptr(uintptr(hint), t.bucket.size)
	if overflow || mem > maxAlloc {
		hint = 0
	}

	// initialize Hmap
	if h == nil {
		h = new(hmap)
	}
	h.hash0 = fastrand()
	
    // 根据元素个数 与 负载因子 确定 B 的大小
	// Find the size parameter B which will hold the requested # of elements.
	// For hint < 0 overLoadFactor returns false since hint < bucketCnt.
	B := uint8(0)
	for overLoadFactor(hint, B) {
		B++
	}
	h.B = B
	
	// 分配 buckets 数组
    // allocate initial hash table
	// if B == 0, the buckets field is allocated lazily later (in mapassign)
	// If hint is large zeroing this memory could take a while.
	if h.B != 0 {
		var nextOverflow *bmap
		h.buckets, nextOverflow = makeBucketArray(t, h.B, nil)
		if nextOverflow != nil {
			h.extra = new(mapextra)
			h.extra.nextOverflow = nextOverflow
		}
	}

	return h
}
~~~

##### 计算B

> B的计算和map的元素可以hint有关、并且和负载因子有关

~~~go
// overLoadFactor reports whether count items placed in 1<<B buckets is over loadFactor.
func overLoadFactor(count int, B uint8) bool {
	return count > bucketCnt && uintptr(count) > loadFactorNum*(bucketShift(B)/loadFactorDen)
}
// 依次将B uint8 = 0 与负载因子计算 loadFactorNum / loadFactorDen * bucketShift(B)
// bucketShift returns 1<<b, optimized for code generation.
func bucketShift(b uint8) uintptr {
	// Masking the shift amount allows overflow checks to be elided.
	return uintptr(1) << (b & (sys.PtrSize*8 - 1))
}
~~~

和负载因子关系如下

太大的负载因子有如下问题

~~~
too large and we have lots of overflow, buckets, too small and we waste a lot of space
~~~

所以经过验证，官方将负载因子定为6.5

~~~go
// Maximum average load of a bucket that triggers growth is 6.5.
// Represent as loadFactorNum/loadFactorDen, to allow integer math.
loadFactorNum = 13
loadFactorDen = 2
~~~

所以上述初始化的B

| B值  | 不等式                    | 结果            |
| ---- | ------------------------- | --------------- |
| 0    | 16≤ 2^0 * 6.5 => 16 ≤ 6.5 | 不成立，B递增1  |
| 1    | 16 ≤ 2^1 * 6.5 => 16 ≤ 13 | 不成立，B递增1  |
| 2    | 16 ≤ 2^2 * 6.5 => 16 ≤ 26 | 成立，B结束递增 |

同时也和Map初始化hint也就是count关系，元素数量需要大于等于bucketCnt

```go
 // Maximum number of key/elem pairs a bucket can hold.  一个bucket默认最大的key-value对数
 bucketCntBits = 3
 bucketCnt     = 1 << bucketCntBits
```

否则B默认为0，后面可以

```
if B == 0, the buckets field is allocated lazily later (in mapassign)
```

##### buckets

计算完B的大小，那么就到了分配BucketArray数组 = 1 << b **实际上就是 2 ^ B**

~~~go
// makeBucketArray initializes a backing array for map buckets.
// 1<<b is the minimum number of buckets to allocate.
func makeBucketArray(t *maptype, b uint8, dirtyalloc unsafe.Pointer) (
    buckets unsafe.Pointer, nextOverflow *bmap) {
    // 计算桶的数量 1 << b
	base := bucketShift(b)
	nbuckets := base
	// For small b, overflow buckets are unlikely.
	// Avoid the overhead of the calculation.
	if b >= 4 {
		// Add on the estimated number of overflow buckets
		// required to insert the median number of elements
		// used with this value of b.
		nbuckets += bucketShift(b - 4)
		sz := t.bucket.size * nbuckets
		up := roundupsize(sz)
		if up != sz {
			nbuckets = up / t.bucket.size
		}
	}

	if dirtyalloc == nil {
		buckets = newarray(t.bucket, int(nbuckets))
	} else {
		// dirtyalloc was previously generated by
		// the above newarray(t.bucket, int(nbuckets))
		// but may not be empty.
		buckets = dirtyalloc
		size := t.bucket.size * nbuckets
		if t.bucket.ptrdata != 0 {
			memclrHasPointers(buckets, size)
		} else {
			memclrNoHeapPointers(buckets, size)
		}
	}

	if base != nbuckets {
		// We preallocated some overflow buckets.
		// To keep the overhead of tracking these overflow buckets to a minimum,
		// we use the convention that if a preallocated overflow bucket's overflow
		// pointer is nil, then there are more available by bumping the pointer.
		// We need a safe non-nil pointer for the last overflow bucket; just use buckets.
		nextOverflow = (*bmap)(add(buckets, base*uintptr(t.bucketsize)))
		last := (*bmap)(add(buckets, (nbuckets-1)*uintptr(t.bucketsize)))
		last.setoverflow(t, (*bmap)(buckets))
	}
	return buckets, nextOverflow
}
~~~

接下来就是buckets的内部结构了，buckets是一个数组，数组的成员是bmap

~~~go
// A bucket for a Go map.
type bmap struct {
	// tophash generally contains the top byte of the hash value
	// for each key in this bucket. If tophash[0] < minTopHash,
	// tophash[0] is a bucket evacuation state instead.
    // 一个bmap最多8个 k-v 键值对
	tophash [bucketCnt]uint8
	// Followed by bucketCnt keys and then bucketCnt elems.
	// NOTE: packing all the keys together and then all the elems together makes the
	// code a bit more complicated than alternating key/elem/key/elem/... but it allows
	// us to eliminate padding which would be needed for, e.g., map[int64]int8.
	// Followed by an overflow pointer.
}
~~~

注意，这个结构并不是最终的bmap，编译器会动态的创建如下结构

~~~go
type bmap struct {
    topbits  [8]uint8
    keys     [8]keytype
    values   [8]valuetype
    pad      uintptr
    overflow uintptr
}
~~~

如图所示的存储方式

![bmap](https://gitee.com/GodYao1995/resources/raw/master/images/bmap.svg)

##### 查找

~~~go
// mapaccess1 returns a pointer to h[key]
func mapaccess1(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer {
    
	......
    // 计算 key 的 hash
	hash := t.hasher(key, uintptr(h.hash0))
    
   
    // 让 Key 的hash值 落在 buckets数组范围内，也就是计算 hash 的低 B 位
	m := bucketMask(h.B)
    // 通过 m 与 hash 计算 buckets 的首地址 
	b := (*bmap)(add(h.buckets, (hash&m)*uintptr(t.bucketsize)))
    
    // 扩容
	if c := h.oldbuckets; c != nil {
		if !h.sameSizeGrow() {
			// There used to be half as many buckets; mask down one more power of two.
			m >>= 1
		}
        // 求在oldbuckets的位置
		oldb := (*bmap)(add(c, (hash&m)*uintptr(t.bucketsize)))
		if !evacuated(oldb) {
			b = oldb
		}
	}
    // 计算 hash 高 8 位
	top := tophash(hash)
    
// 进入 bucket 的循环 8 个 slot
bucketloop:
	for ; b != nil; b = b.overflow(t) {
        // 8 个 位置
		for i := uintptr(0); i < bucketCnt; i++ {
			if b.tophash[i] != top {
				if b.tophash[i] == emptyRest {
					break bucketloop
				}
				continue
			}
            // bucket 的 key , dataOffset是bmap起始的偏移
			k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))
			if t.indirectkey() {
				k = *((*unsafe.Pointer)(k))
			}
            // 判断 key 存在，然后定位 value
			if t.key.equal(key, k) {
				e := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.elemsize))
				if t.indirectelem() {
					e = *((*unsafe.Pointer)(e))
				}
				return e
			}
		}
	}
	return unsafe.Pointer(&zeroVal[0])
}
~~~

##### 核心过程

1. Hash值
2. 低B位，确定bucket的地址
3. tophash 高8位确定key的位置

##### 插入

~~~go
func mapassign(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer
~~~

##### 删除

~~~go
func mapdelete(t *maptype, h *hmap, key unsafe.Pointer)
~~~

##### 扩容

> TODO