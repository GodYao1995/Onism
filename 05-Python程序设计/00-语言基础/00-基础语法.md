[TOC]

### Py

#### Py特点？

1. 易于使用、快速开发
2. 解释性，不需要编译和链接
3. 超shell脚本、awk功能
4. 内置高级数据类型、超多标准库
5. 模块化编程

#### Py范围？

1. 后端开发 - Python / Java / Go / PHP
2. DevOps - Python / Shell / Ruby
3. 数据采集 - Python / C++ / Java
4. 量化交易 - Python / C++ / R
5. 数据科学 - Python / R / Julia / Matlab
6. 机器学习 - Python / R / C++ / Julia
7. 自动化测试 - Python / Shell

#### Advise

1. Make English as your working language. （让英语成为你的工作语言）
2. Practice makes perfect. （熟能生巧）
3. All experience comes from mistakes. （所有的经验都源于你犯过的错误）
4. Don't be one of the leeches. （不要当伸手党）
5. Either outstanding or out. （要么出众，要么出局）

#### 解释器

> 需要下载安装解释器环境

1. 交互环境
2. 源文件, Py3默认UTF-8编码

~~~python
# -*- coding: encoding -*-
~~~

#### 简单类型

1. 定义变量

~~~python
num = 10
string = "Hello World"
flag = True
lst = [1, 2, 3, "abc"]
a, b = 1, 2
~~~

2. 简单操作

~~~python
len(seq)
sublst = lst[0:2]
print(f"{num}")
concat = string + "!"
~~~

3. 操作符号

~~~python
+ - * / % // **
> >= < <= !=
= += -= *= /= %= //= **=
~~~

#### 流程控制

##### if

~~~python
if condition:
    pass
else:
    pass
~~~

##### for

~~~python
for item in iterable:
    pass

for item in iterable:
	pass
# for-end-time-exec or no-break
else:
    pass
~~~

##### range

~~~python
for i in range(10):
    pass
~~~

##### break

~~~python
for item in iterable:
    if condition:
        break
~~~

##### pass

> 1. 当语法上需要一个语句，但程序需要什么动作也不做时，可以使用它
> 2. 在你编写新的代码时作为一个函数或条件子句体的占位符

~~~python
# do nothing
pass
~~~

##### def

1. 定义

> 1. 函数的 *执行* 会引入一个用于函数局部变量的新符号表。 更确切地说，函数中所有的变量赋值都将存储在局部符号表中；而变量引用会首先在局部符号表中查找，然后是外层函数的局部符号表，再然后是全局符号表，最后是内置名称的符号表。 因此，全局变量和外层函数的变量不能在函数内部直接赋值（除非是在 [`global`](https://docs.python.org/zh-cn/3.9/reference/simple_stmts.html#global) 语句中定义的全局变量，或者是在 [`nonlocal`](https://docs.python.org/zh-cn/3.9/reference/simple_stmts.html#nonlocal) 语句中定义的外层函数的变量），尽管它们可以被引用
> 2. 在函数被调用时，实际参数（实参）会被引入被调用函数的本地符号表中；因此，实参是通过 *按值调用* 传递的
> 3. 无返回值默认返回None

~~~python
def foo(param1: str, param2: str = "Hello") -> str:
    """ foo doc """
   return param1 + param2

def bar(*args, **kwargs):
    pass

fn = lambda x: x + 1
~~~

2. 参数

> 函数的参数传递形式可以是位置参数或是显式的关键字参数
>
> 使用仅限位置形参可以防止形参名称在未来被修改时造成破坏性的 API 变动
>
> 1. / 之前是位置参数
> 2. \*之后是关键字参数
> 3. /\*之间可以是位置也可使关键字

~~~python
# 强制区分位置参数、关键字参数
# bar(1, 2, 3, kwd1=1, kwd2=2)    
# bar(1, 2, pos3=3, kwd1=1, kwd2=2)  
def bar(pos1, pos2, /, pos3, *, kwd1, kwd2):
    pass

def goo(*args):
    pass

def moo(**kwagrs):
    pass
~~~

##### 总结

~~~python
def param(pos, *args, default=None, kwd1, kwd2, **kwargs):
    pass
~~~

#### 编程风格

1. 4个空格缩进
2. 单行不超过79
3. 空行分隔函数和类
4. 注释单独一行
5. 文档字符串
6. 运算符前后空格（括号不需要）
7. 下划线命名

#### 数据结构

##### List

> 1. 索引、遍历、切片
> 2. 解包

~~~python
lst = list()
list.append(x)
list.extend(iterable)
list.insert(i, x)
list.remove(x)
list.pop([i]) // []表示可选
list.clear()
list.index(x, [start, [end]])
list.count(x)
list.sort(*, key=None, reverse=False)
list.reverse()
list.copy()
del lst[index]
del lst[:]
# 推导
lst = [x for x in range(10)]
[(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]
[[row[i] for row in lst] for i in range(20)]

for i, v in enumerate(lst):
    pass
for a, b in zip(lsta, lstb):
    pass
~~~

##### tuple

> 1. 元组是 [immutable](https://docs.python.org/zh-cn/3.9/glossary.html#term-immutable) （不可变的），其序列通常包含不同种类的元素
> 2. 通过解包、索引、迭代操作
> 3. 单个元素需要加逗号

~~~python
tuple1 = 1, 2, 3
tuple2 = (1, 2, 3)
~~~

##### set

> 1. 不重复元素组成的无序的集、基本用法包括成员检测和消除重复元素
> 2. 支持像 联合，交集，差集，对称差分等数学运算
> 3. 创建一个空集合你只能用 `set()`

~~~python
basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
empty = set()
a = {x for x in 'abracadabra' if x not in 'abc'}
set()
~~~

##### dict

> 1. Key-Value模式
> 2. 键必须是唯一的（在一个字典中）,并且必须是不可变对象

~~~python
emptydict = {}
emptydict = dict()
d = {
    "key": "value"
}
dict(k1="v1", k2="v2"m "k3=v3")
dict([("k1", "v1"), ("k2", "v2"), ("k3", "v3")])
d = {x: x**2 for x in (2, 4, 6)}

if k in d:
    pass

for k, v in d.items():
    pass
for k in d.keys():
    pass
for v in d.values():
    pass

del d["key"]

dict.clear()
dict.copy()
dict.pop(x)
dict.popitem()
dict.get(x)
~~~

#### 操作符

~~~python
in not in
and not or
~~~

#### 模块

1. 模块

> 1. 模块是一个包含Python定义和语句的文件
> 2. 模块中的定义可以 *导入* 到其它模块或者 *主* 模块
> 3. 在一个模块内部，模块名（作为一个字符串）可以通过全局变量 `__name__` 的值获得
> 4. 首先寻找具有该名称的内置模块。如果没有找到，然后解释器从 [`sys.path`](https://docs.python.org/zh-cn/3.9/library/sys.html#sys.path) 变量给出的目录列表里寻找

~~~python
import xModule
from xxPkg import xx
from xxPkg import *  # 调入所有非以下划线（_）开头的名称
import xModule as x

if __name__ == "__main__":
    pass
~~~

2. 缓存

> 1. 为了加速模块载入，Python在 `__pycache__` 目录里缓存了每个模块的编译后版本
> 2. Python根据编译版本检查源的修改日期，以查看它是否已过期并需要重新编译
> 3. Python在两种情况下不会检查缓存。首先，对于从命令行直接载入的模块，它从来都是重新编译并且不存储编译结果；其次，如果没有源模块，它不会检查缓存。为了支持无源文件（仅编译）发行版本， 编译模块必须是在源目录下，并且绝对不能有源模块
> 4. 你可以在Python命令中使用 [`-O`](https://docs.python.org/zh-cn/3.9/using/cmdline.html#cmdoption-o) 或者 [`-OO`](https://docs.python.org/zh-cn/3.9/using/cmdline.html#cmdoption-oo) 开关， 以减小编译后模块的大小。 `-O` 开关去除断言语句，`-OO` 开关同时去除断言语句和 __doc__ 字符串

3. 标准模块

~~~python
import sys
import os
~~~

4. dir

> 查找模块定义的名称

~~~python
import sys
dir(sys)
dir
~~~

5. 包

> 1. 包是一种通过用“带点号的模块名”来构造 Python 模块命名空间的方法
> 2. 必须要有 `__init__.py` 文件才能让 Python 将包含该文件的目录当作包
> 3. 在最简单的情况下,`__init__.py` 可以只是一个空文件,但它也可以执行包的初始化代码或设置 `__all__` 变量

6. import *

> [`import`](https://docs.python.org/zh-cn/3.9/reference/simple_stmts.html#import) 语句使用下面的规范：如果一个包的 `__init__.py` 代码定义了一个名为 `__all__` 的列表，它会被视为在遇到 `from package import *` 时应该导入的模块名列表

~~~python
# 定义导出名称
__all__ = ["echo", "surround", "reverse"]
~~~

#### 输入输出

1. 字符串

~~~python
print(f"{param1},{param2}")

"{}, {}, {}".format("a", "b", "c")
"{1}, {0}, {2}".format("a", "b", "c")
"{0}, {1}, {other}".format("a", "b", other="c")

table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}
'Jack: {0[Jack]:d}; Sjoerd: {0[Sjoerd]:d}; Dcab: {0[Dcab]:d}'.format(table)
# d代表宽度
'Jack: {Jack:d}; Sjoerd: {Sjoerd:d}; Dcab: {Dcab:d}'.format(**table)

str() # 用于返回人类可读的值的表
repr()# 解释器可读
~~~

2. 读写文件

> 在处理文件对象时，最好使用 [`with`](https://docs.python.org/zh-cn/3.9/reference/compound_stmts.html#with) 关键字

~~~python
f = open(path, mode)
f.read()
f.readline()
f.write()
f.tell()
for line in f:
    pass
json.dump(x, f)
json.load(f)
~~~

#### 错误异常

> 1. 语法错误又称解析错误，未遵守语法规则
> 2. 在执行时检测到的错误被称为异常

1. 处理异常

~~~python
try:
   
except ValueError as e:
    pass
except (RuntimeError, TypeError, NameError):
    pass
except:
    pass
# 没有异常时执行
else:
    pass
# 不论 try 语句是否产生了异常都会被执行，对于释放外部资源（例如文件或者网络连接）非常有用
finally:
    pass
~~~

2. 抛出异常

~~~python
raise ValueError
~~~

3. 定义异常

~~~python
class Error(Exception):
    pass
class ParamError(Error):
    def __init__(self, expression, message):
        self.expression = expression
        self.message = message
~~~

4. 预定义清理

~~~python
with open(path, mode) as f:
    pass
~~~

#### 类

> 1. 类提供了一种组合数据和功能的方法
> 2. Python 的类提供了面向对象编程的所有标准特性：类继承机制允许多个基类，派生类可以覆盖它基类的任何方法，一个方法可以调用基类中相同名称的的方法。对象可以包含任意数量和类型的数据。和模块一样，类也拥有 Python 天然的动态特性：它们在运行时创建，可以在创建后修改

1. 命名空间

> 1. 是一个从名字到对象的映射。 大部分命名空间当前都由 Python 字典实现
> 2. 内建命名空间：解释器启动时创建的，永远不会被删除
> 3. 模块命名空间：模块定义被读入时创建；通常，模块命名空间也会持续到解释器退出
> 4. 函数命名空间：一个函数的本地命名空间在这个函数被调用时创建，退出时释放

2. 作用域

> 一个 *作用域* 是一个命名空间可直接访问的 Python 程序的文本区域

1. 最先搜索的最内部作用域包含局部名称
2. 从最近的封闭作用域开始搜索的任何封闭函数的作用域包含非局部名称，也包括非全局名称
3. 倒数第二个作用域包含当前模块的全局名称
4. 最外面的作用域（最后搜索）是包含内置名称的命名空间

> 1. global语句可被用来表明特定变量生存于全局作用域并且应当在其中被重新绑定
> 2. nonlocal 语句表明特定变量生存于外层作用域中并且应当在其中被重新绑定

3. 定义类

~~~python
class User(object):
    """ class doc """
    # 类静态属性，类变量
    className = "User"
    
    def __init__(self, name):
        # 实例变量
        self.name = name
	# 绑定方法
    def get_name(self) -> str:
        return self.name
    def upper_name(self) -> str:
        return self.get_name().capitalize()
	# 类方法
    @classmethod
    def tool(cls):
        pass
    # 静态方法
    @staticmethod
    def static():
        pass
    
u = User("Jack")
~~~

4. 继承

> 1. 所有类都是继承自 [`object`](https://docs.python.org/zh-cn/3.9/library/functions.html#object)
> 2. 使用 [`isinstance()`](https://docs.python.org/zh-cn/3.9/library/functions.html#isinstance) 来检查一个实例的类型: `isinstance(obj, int)` 
> 3. 使用 [`issubclass()`](https://docs.python.org/zh-cn/3.9/library/functions.html#issubclass) 来检查类的继承关系: `issubclass(bool, int)`

~~~python
class SonClass(FatherClass):
    pass
class SonClass(FatherClass, MotherClass):
    pass
~~~

5. 私有变量

> 1. 带有一个下划线的名称 (例如 `_spam`) 应该被当作是 API 的非公有部分
> 2. 约定的形式

6. 迭代器

> 1. 容器以及序列都可以使用for循环
> 2. 在幕后，[`for`](https://docs.python.org/zh-cn/3.9/reference/compound_stmts.html#for) 语句会在容器对象上调用 [`iter()`](https://docs.python.org/zh-cn/3.9/library/functions.html#iter)。 该函数返回一个定义了 [`__next__()`](https://docs.python.org/zh-cn/3.9/library/stdtypes.html#iterator.__next__) 方法的迭代器对象，此方法将逐一访问容器中的元素
> 3. 当元素用尽时，[`__next__()`](https://docs.python.org/zh-cn/3.9/library/stdtypes.html#iterator.__next__) 将引发 [`StopIteration`](https://docs.python.org/zh-cn/3.9/library/exceptions.html#StopIteration) 异常来通知终止 `for` 循环

~~~python
it = iter("abc")
next(it)
next(it)
next(it)
~~~

#### 标准库

1. 基本库

~~~python
import os     		# 操作系统
import shutil 		# 文件目录
import glob   		# 文件搜索
import sys    		# 命令行参数，错误输出重定向
import re			# 正则表达式
import math			# 数学
import random       # 随机数
import statistics   # 数据统计 中位数、均值、方差
import smtplib		# 邮件
from urllib.request import urlopen # HTTP
from datetime import date # 日期
import zlib 	          # 压缩
from timeit import Timer  # 性能测量
import doctest            # 测试doc中的例子
import unittest			  # 单元测试
import logging            # 日志
from decimal import *     # 十进制浮点数 财务、控制精度
~~~

2. 多线程

> 1. 问题：相互协调的多个线程之间需要共享数据或其他资源。
>
> 2. 为此，threading 模块提供了多个同步操作原语，包括线程锁、事件、条件变量和信号量
>
> 3. 实现多任务协作的首选方法是将所有对资源的请求集中到一个线程中
>
>     然后使用 [`queue`](https://docs.python.org/zh-cn/3.9/library/queue.html#module-queue) 模块向该线程供应来自其他线程的请求

~~~python
import threading, zipfile
class AsyncZip(threading.Thread):
    def __init__(self, infile, outfile):
        threading.Thread.__init__(self)
        self.infile = infile
        self.outfile = outfile

    def run(self):
        f = zipfile.ZipFile(self.outfile, 'w', zipfile.ZIP_DEFLATED)
        f.write(self.infile)
        f.close()
        print('Finished background zip of:', self.infile)

background = AsyncZip('mydata.txt', 'myarchive.zip')
background.start()
print('The main program continues to run in foreground.')
# Wait for the background task to finish
background.join()    
print('Main program waited until background was done.')
~~~

#### 虚拟环境

> pipenv or 其他方式

#### 包

~~~bash
pip search pkg
pip install pkg
pip uninstall pkg
pip show pkg
pip install --upgrade
pip list
pip freeze -> requirement.txt
~~~