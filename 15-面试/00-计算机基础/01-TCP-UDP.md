[TOC]

## TCP/IP协议

### TCP概述

> **TCP（Transmission Control Protocol）传输控制协议**

#### TCP连接

TCP连接是一种抽象的概念，表示一条可以通信的链路
每个TCP连接有且仅有两个端点，表示通信的双方，且双方在任意时刻都可以作为发送者和接受者

1.  **面向连接的、可靠的字节流服务**
2.  **全双工通信，TCP两端既可以作为发送端也可以作为接收端**
3.  通过TCP连接交换8bit字节构成的字节流，并且不会在字节流中插入标识符，称此服务为字节流服务

#### 可靠性

1. 应用数据被分为TCP最适合发送的数据块
2. 发送报文段会启动定时器，等待目的端确认收到这个报文段，如果不能及时收到一个确认，将重发
    * 自适应超时
    * 重传策略
3. 发送的确认不是立即发送，而是推迟几分之一秒
4. TCP将保持它首部和数据的校验和，如果初选差错，将会丢弃这个报文段和不确认收到(希望超时重发)
5. TCP报文段作为IP数据报传输，而IP数据报到达可能会失序，因此TCP到达也可能会失序，TCP重排序交付上层
6. IP数据报会发生重复，TCP的接收端必须丢弃重复的数据
7. TCP提供流量控制，TCP连接每一方都有固定大小的缓冲空间，接收端只允许发送端发送接收端缓冲区接纳的数据

#### TCP报文格式

##### IP数据报

![IP数据报](images/IP数据报.svg)

##### TCP首部

> 最多60字节，不计任选字段，TCP首部通常是20字节

![TCP首部](images/TCP首部.svg)

1. 16位源端口和16位目的端口号,

    * 用于寻找发送端和接收端
    * **源IP地址、源端口、目的IP地址、目的端口组成四元组，唯一确定一个TCP连接(的双方)**
    * 一个IP和一个端口也称为Socket

2. 32位序号

    * 标识从发送端向接收端发送的数据字节流，它表示这个报文段中的第一个数据字节
    * TCP用序号对每个字节进行计数，2^32，达到最大后又会从0开始
    * **当建立新的连接，SYN=1，序号字段包含初始序列=ISN,那么发送的数据的第一个字节序号=ISN+1**

3. 32位确认号

    * 确认序号包含发送确认的一端所期望收到的下一个序号
    * 确认序号应当是上次已经成功收到的数据字节序号加1，此时ACK=1
    * ACK在连接建立后总是被设置为1

4.  **TCP为应用层提供全双工服务，两个方向上的数据独立进行传输，因此每一端必须保持每个方向上的传输序号**

5. 4bit首部长度，TCP选项字段原因TCP首部是可变的，通常为空，典型长度是20字节

6. 6个标志比特

    *   ACK：确认序号有效
    *   RSTL：重建链接
    *   SYN: 同步序号发起连接建立
    *   FIN：发送端完全发送任务
    *   PSH：接收方应该尽快将数据交给上层
    *   URG：紧急指针有效

7.  16位接收窗口，用于流量控制，最大为65535字节

8.  **16位校验和，覆盖整个TCP首部与数据，强制字段，发端计算和存储，收端进行验证**

9.  选项，MSS，**最大报文长度**，通常在建立连接的第一个报文段(设置SYN=1的报文段)指明这个选项

    * 默认536
    * 或者BSD等默认是512的倍数如1024，MSS不同的实现有不同的值设置

    

### TCP连接建立与终止

> TCP是面向连接的协议，在传输数据之前需要建立一条抽象的数据链路

#### 连接-三次握手

> Three-Way Handshake

##### 流程

![三次握手详解](./images/TCP-3.svg)

1.  客户端发送SYN报文段
    * 指明客户端连接服务端的端口
    * 将标志位SYN=1, 初始序列号ISN=X, MSS=1024、Wind=4096(具体看) 【ISN == SEQ序列号】
    * 进入SYN_SEND状态
2.  服务器收到客户端发送到的SYN报文段

    *   分配缓存区和保持TCP变量
    *   标志位SYN=1
    *   标志位ACK=1，并且将客户端的ISN + 1即是X + 1作为ACK确认序号
    *   服务端初始序列号ISN=Y 
    *   发送ACK-SYN报文段，对客户端的SYN进行确认
    *   进入SYN_RECV状态
3.  客户端收到服务端的SYN-ACK报文段

    *   分配缓存区和保持TCP变量
    *   标志位SYN=0, 标志位ACK=1， 并且将服务的的ISN +1即是Y + 1作为ACK确认序号
    *   进入ESTABLISHED状态

完成连接以后，双方就可以发送数据，以后的SYN=0，ACK=1

##### 注意

1. ISN随时间而变化，每个连接都将具有不同的ISN，系统初始化时ISN=1，此后每8ms加1，每次建立一个连接这个变量将增加64000
2. 前两次握手没有携带TCP数据，第三次可以携带数据

##### 三次？

**引入三次握手的主要原因是: 为了避免过时的重复连接在再次建立时造成的混乱**

>   在三次握手中，每一端都是先发出SYN报文段，其中含有各自的起始序列号;然后每一端都要确认对方的 SYN 报文段 。 这样就可以排除当重复的过时报文段到达某一端时可能带来的混淆。此外，常规的 TCP不会在进入ESTABLISHED状态之前就把在SYN报文段中一起传送过来的数据交付给上层的用户进程

在说明为什么需要"三次握手"之前，必须知道TCP建立的"连接"，是一条逻辑上的连接【 Socket、序列号以及窗口大小】

1. Socket 四元组信息
2. 序号 追踪数据、确认消息
3. 窗口 流量控制

问题可以即是：什么样的连接建立过程可以完成以上的三个信息的初始化，并且建立**可靠的连接**

两次握手情况下，无法避免发送方由于网络问题，可能发送的多次连接请求。**两次情况下，接收方只能被动接受或者拒绝，不能分辨是否是过时的连接报文段**。所以接收方只能回复ISN + 1 ACK确认,  然后将判断的权限给到发送方

1. 如果当前连接是历史连接，即 `SEQ` 过期或者超时，那么发送方就会直接发送 `RST` 控制消息中止这一次连接
2. 如果当前连接不是历史连接，那么发送方就会发送 `ACK` 控制消息，通信双方就会成功建立连接

**使用三次握手和 `RST` 控制消息将是否建立连接的最终控制权交给了发送方，因为只有发送方有足够的上下文来判断当前连接是否是错误的或者过期的，这也是 TCP 使用三次握手建立连接的最主要原因，并且也避免浪费接受方资源**

**引入三次握手的第二个原因是: 为了利用序号进行可靠的数据传输**

网络传输是不可靠的，存在丢失、无序。而序号机制，可以使得数据超时重发、排序。

TCP 可以通过不同的机制来初始化序列号，作为 TCP 连接的接收方我们无法判断对方传来的初始化序列号是否过期，所以我们需要交由对方来判断，TCP 连接的发起方可以通过保存发出的序列号判断连接是否过期

**总结**

1. **三次握手的ACK确认机制可避免过时的重复连接在再次建立连接时造成的混乱，以及减少浪费接收方的资源**
2. **初始化序号为后续的数据传输做准备**
3. 第二次的SYN与ACK可以同时发送，所以可以减少一次，综合来说三次是最小完成通信连接的次数

核心：要理解三次握手，需要知道，

1. 第一：socket连接是什么 
2. 第二：到底理解不理解被动方的意义(SYN洪水、半连接、建立连接控制权限) 
3. 第三：可靠传输准备(序号机制、连接变量保持) 
4. 第四：资源最小化

#### 终止-四次挥手

##### 流程

![四次挥手详解](./images/TCP-4.svg)

1.  客户端发送FIN报文段, 标志位FIN=1, ACK=1, ISN = X, 进入**FIN_WAIT_1**状态
2.  服务端收到FIN报文段，并且服务端发送FIN报文段, 标志位ACK=1, ACK= X + 1, ISN = Y, 进入**CLOSE_WAIT**状态,
3.  客户端收到校验后进入**FIN_WAIT_2**状态
4.  服务端发送FIN包, 标志位FIN=1,ACK=1, ISN = Z, 进入**LAST_ACK**状态
5.  客户端收到并且校验, 发送ACK包, FIN=0, ACK=1, ACK= Z + 1, 进入**TIME_WAIT**状态
6.  服务端收到后进入**CLOSE**状态
7.  TIME_WAIT时间后客户端连接断开，连接资源被释放

##### 半关闭

> TCP提供了连接一端在结束他的发送后，还能接受另一端的数据的能力，称为半关闭

##### 四次挥手？

半关闭造成的。**TCP是全双工的，即是数据在两个方向能同时传递，因此每个方向必须单独关闭**，被动断开的一方可能会有数据需要发送, 并且断开与否实际上是上层应用决定, 并非协议本身决定的

##### TIME_WAIT(2MSL)

> 1. TIME_WAIT状态也称为2MSL等待状态
> 2. 每个具体TCP实现必须选择一个报文段最大生存时间**MSL(任何报文段被丢弃前在网络内的最长时间)**，该时间是有限的，TCP报文段以IP数据报的形式在网络传输，而IP数据报有TTL字段
> 3. **MSL常用值4分钟、2分钟、1分钟、30秒**
> 4. IP数据报TTL的限制是基于跳数而不是定时器

**对于一个具体实现给定的MSL值：当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留的时间为2MSL。这样可让TCP再次发送最后的ACK，以防这个ACK丢失(另一段重发最后的FIN)**

###### 目的1

> 可靠地实现TCP全双工连接的终止

**TCP协议在关闭连接的四次握手过程中，最终的ACK是由主动关闭连接的一端（后面统称A端）发出的，如果这个ACK丢失，对方（后面统称B端）将重发出最终的FIN，因此A端必须维护状态信息（TIME_WAIT）允许它重发最终的ACK。如果A端不维持TIME_WAIT状态，而是处于CLOSED 状态，那么A端将响应RST分节，B端收到后将此分节解释成一个错误**

**因而，要实现TCP全双工连接的正常终止，必须处理终止过程中四个分节任何一个分节的丢失情况，主动关闭连接的A端必须维持TIME_WAIT状态** 

如果重发的FIN报文段在客户端仍处于TIME_WAIT状态，那么最后ACK会重传，并且TIME_WAIT时间重置。

**总结：主动关闭方在TIME_WAIT时间内保留连接信息，便于重传最后的ACK**

###### 目的2

>   使过时的重复报文段作废

**在关闭“前一个连接”之后，马上又重新建立起一个相同的IP和端口之间的“新连接”，“前一个连接”的重复分组在“前一个连接”终止后到达，而被“新连接”收到了。为了避免这个情况，TCP协议不允许处于TIME_WAIT状态的连接启动一个新的可用连接，因为TIME_WAIT状态持续2MSL，就可以保证当成功建立一个新TCP连接的时候，来自旧连接重复分组已经在网络中消逝**

TCP协议的运作基于一个基本的假设：互联网的每一个IP数据报都有一个有限的生产期限由IP首部TTL决定，IP数据报每经过一个路由器转发TTL就减1，TTL8个bit，因此最多转发255次。

**2MSL等待的结果是这个TCP连接在等待期间，定义这个连接的四元组插口对不能被使用，只能在2MSL结束后才能被使用**。一个新的连接替身在2MSL后建立，由于2MSL的存在前一个连接的过时重复报文在1个MSL就消失，所以过时的报文不可能被误认为是第二次连接的报文段

**总结：2MSL保证前一次连接的过时重复报文段不会在新的连接中出现**

###### 出现大量TIME_WAIT？

1.  高并发短链接的TCP服务器，处理完请求后主动关闭链接
2.  解决办法
    * 可以进行TIME_WAIT快速回收和重用，控制数量【通过配置】
    
    * Web服务器首先关闭来自负载均衡服务器(Nginx)的链接
    
        > 代理使用短链接的方式和后端交互的原因，使得nginx和后端的ESTABLISHED变得很少而TIME_WAIT很多

### 可靠传输

> 应用数据分割、数据报编号、校验和、ACK确认机制、流量控制、拥塞控制、超时重传

#### 问题？

1.  差错校验？比特差错问题，合适的数据块分割【校验和】
2.  接收方反馈【ACK机制】
3.  数据报编号【序号机制】
4.  数据报丢失【超时重发】

#### 解决方案[差错恢复]

##### ARQ协议

###### 校验和

TCP/UDP首部字段，因特网校验和用来确定差错校验

###### 确认反馈

ACK确认机制，每发送一个分组就需要确认，或者采取累积确认方式

###### 序号机制

每个分组或者报文段都有序号，用来检测丢失分组和冗余分组

###### 超时重发

每发送一个分组就启动一个定时器，超时就会重传，序号用来处理冗余分组

##### 流水线协议

不以停等的方式确认，允许发送多个分组而无需等待，只要后面发送方累积确认，收到一个ACK

###### 回退N步[滑动窗口协议]

必须是有序的分组/报文段

1.  滑动窗口
    *   窗口长度N
    *   Base基序号
    *   Nextseqnum 最小未使用序号，下一个待发分组
2.  窗口分组状态
    *   已经确认
    *   发送，未确认
    *   可用，未发送
    *   不可用
3.  发送方流程
    *   检测窗口是否已经满，未满，产生分组发送，已满等待
    *   GBN协议，采用累积确认收到一个ACK，表示接收方已经正确接收到n序号以及n以前的所有分组
    *   超时发送未被确认的分组
4.  接收方
    *   正确收到，就交给上层
    *   如果遇到丢失分组，回退到最近按序接收分组，丢弃所有失序分组
    *   等待发送方重传

###### 选择重传[SR]

可以是无序的分组

1.  GBN有信道利用率问题，有很多分组没必要重传
2.  选择重传通过发送方重传哪些它怀疑在接收方丢失或者受损的分组，避免不必要重传
3.  接收方
    *   确认收到一个分组，不管其是否按照顺序
    *   **失序的分组将被缓存**，直到所有的丢失分组被接收到为止，然后统一排序交付上层

#### TCP可靠传输机制？

除了以上提供的基础可靠传输外，如差错检测，确认机制，序号机制，超时重传机制，TCP具有如下特殊的机制

##### 超时重传[超时时间]

TCP重传具有最小序号还未被确认的报文段，每次重传后都会将下一次的超时时间加倍

##### 快速重传[冗余ACK]

1.  如果接收方接收到一个不被期望的序号，大于下一个所期望的按序的报文段，也就是报文丢失
2.  TCP就会对已经接收到的最后一个按序字节数据进行重复确认
3.  一旦接收到三次冗余的ACK，那么TCP就会进行快速重传，在该定时器过期之前重传丢失报文段

##### TCP GBN or SR？

1.  TCP是累积确认的，TCP正确接收失序的报文段，可以进行排序
2.  **TCP采取的是选择确认**
    *   允许接收方有选择的确认失序报文段，而不是累积的确认最后一个正确接收的有序报文段
    *   所以TCP看起来像SR选择重传，跳过已经被确认过的报文段

##### 流量控制

1.  目的
    *   一条TCP连接的每一侧都有TCP缓存区，并不是接收到数据就交给上层服务
    *   流量控制就是为了消除发送方使接收方缓冲区溢出的情况，为了匹配发送效率和接收效率
2.  策略
    *   TCP让发送方维持一个接收窗口的变量 receive window 【rwnd】来控制流量
    *   接收方通过给发送方一个指示，接收方还有多少可用的缓存空间
3.  问题？一旦rwnd=0？发送方不在发送怎么办
    *   TCP发送方会继续发送只有一个字节的数据报文段
    *   如果被接收方确认，那么缓存清空，回复一个非0的rwnd

##### 拥塞控制

1.  拥塞原因
    *   网络中数据传输是有容量的，当发送效率越高，吞吐量会降低，时延增加
2.  目的：防止过多的数据注入到网络中，避免路由器、链路过载
3.  代价
    *   当分组到达速率到达链路容量，分组会经历巨大的排队时延
    *   巨大排队时延情况下，分组重传，会额外利用链路带宽
    *   超时丢弃分组，浪费前面使用的链路传输容量以及带宽
4.  如何解决
    *   通过让接收方感知网络的拥塞程度来限制发送效率
    *   **TCP额外跟踪一个变量，拥塞窗口cwnd**
5.  网络拥塞情况
    *   带宽探测，增加速率以响应到达ACK，出现丢包降低速率

##### 拥塞控制算法

**加性增，乘性减，最大阀值控制算法之间的转换**

###### 慢启动

1.  cwnd通常设置为MSS的较小值
2.  **开始cwnd以1个MSS增加，收到一个ACK，就2倍增加，所以启动慢，但是增长快**
3.  cwnd不能无限增长情况1
    *   如果发生丢包时间，设置慢启动阀值ssthresh=cwnd/2，TCP将cwnd=1，并且重新开启慢启动
    *   当cwnd再次到达慢启动阀值，就启动拥塞避免模式

4.  cwnd不能无限增长情况2
    *   如果检测到冗余ACK，那么就执行快速重传，并且进入快速恢复状态
    *   ssthresh=cwnd/2，并且cwnd=ssthresh+3*MSS，进入快速恢复

###### 拥塞避免

1.  cwnd + 一个MSS来缓慢增长
2.  当出现丢包，ssthresh=cwnd/2， 并且cwnd=1
3.  冗余ACK丢包，ssthresh=cwnd/2，并且cwnd=ssthresh+3*MSS，进入快速恢复

###### 快速恢复

1.  如果是引起快速恢复的缺失报文段，对收到的每个冗余ACK，cwnd的值增加一个MSS，当最终一个缺失的报文段到达，TCP降低cwnd，进入拥塞避免
2.  如果是出现超时事件，快速恢复执行慢启动和拥塞避免，最后迁移到慢启动
3.  如果当出现丢包时间，ssthresh=cwnd/2，cwnd=1

### UDP

**UDP（User Data Protocol）用户数据报协议**

1.   无连接
2.  不提供可靠性
3.  面向报文（UDP数据传输单位是报文，不会对数据进行拆分和拼接操作，只是给上层传来的数据加个UDP头或者给下层来的数据去掉UDP头）
4.  没有拥塞控制，始终以恒定速率发送数据
5.  支持一对一、一对多、多对多、多对一
6.  首部开销小，只有8字节

#### IP数据报

![IP数据报-UDP](images/IP数据报-UDP.svg)

#### UDP首部

![UDP首部](images/UDP首部.svg)

1. 端口表示发送进程与接收进程
2. IP分配IP数据报给TCP/UDP，所以TCP与UDP的端口号是独立的
3. UDP校验和是可选的, 如果UDP数据报长度是奇数字节，那么需要填充字节0(为了校验和计算)

#### TCP和UDP区别

1.  TCP面向连接，UDP面向非连接即发送数据前不需要建立链接
2.  TCP提供可靠的服务（数据传输），UDP无法保证
3.  TCP面向字节流，UDP面向报文
4.  **TCP首部20～60字节，UDP首部8字节**
5.  **TCP数据传输比UDP慢，UDP是低延时的**
6.  在一个TCP连接中，仅有两方进行彼此通信，因此广播和多播不能用于TCP
7.  TCP使用校验和，确认和重传机制，累积确认，来保证可靠传输，使用滑动窗口机制来实现流量控制
8.  TCP适用文件、邮件传输，UDP适用直播、视频语音
    * TCP: HTTP、FTP、SMTP
    * UDP: DNS、SNMP

### IP报文

![IP首部](images/IP首部.svg)

1. 4位版本： IPv4

2. 4位首部长度：首部占32bit的数目，最大为60字节

3. 8位服务类型：

    * 3位优先全子字段
    * 4位TOS字段：最小时延、最大吞吐量、最高可靠性、最小费用
    * 1位未用置0

4. 16位总长度：整个IP数据报的长度，最大的为65535字节【大多数情况下都会分片】

    利用首部长度和总长度字段，就可以知道IP数据报中数据内容的起始位置和长度

5. 16位标示：标示每一份数据报

6. 8位TTL(Time-To-Live)：设置了数据报可以经过的最多路由器数

    TTL的初始值由源主机设置（通常为32或64），一旦经过一个处理它的路由器，它的值就减去1，当该字段的值为 0时，数据报就被丢弃，并发送 ICMP 报文通知源主机

