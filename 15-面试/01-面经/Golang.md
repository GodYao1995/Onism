[TOC]

# Golang

## JD

>   GodYao

1.  熟悉Linux以及常用命令 + Git版本控制 + Shell 脚本编程
2.  **计算机基础扎实、操作系统、计算机网络**
3.  **数据结构和算法基础扎实、熟悉面向对象编程、设计模式**
4.  **精通Golang语言、GMP调度、内存管理、通道、锁、协程、以及标准库**
5.  熟悉一门脚本语言如Python、JavaScript
6.  **存储[MySQL]、缓存[Redis]、消息队列[NSQ、RabbitMQ、KafKa]、ELK、Nginx**
7.  **构建高性能、高并发、高可用的大型分布式系统**
8.  **微服务架构、服务发现、分布式链路追踪、gPRC、Protobuffer、etcd **
9.  **Develops（CI、CD）、Docker、K8s**
10.  海量数据处理、数据分析能力、系统设计能力
11.  Web安全问题、XSS、SQL注入等
12.  测试驱动开发、敏捷开发流程、CodeView
13.  阅读优秀源代码以及贡献开源项目
14.  代码整洁、重构

## 大纲

### 一、数据结构

>   数据结构方面主要分为三方面：表、树、图

1.  表

    常见的表有：数组、单链表、双链表、循环链表、散列表

2.  树

    *   主要要解决的一个问题是：树的插入和查找的问题

    *   树主要有：B树、B-树、B+树，字典树，平衡二叉树、红黑树、哈夫曼树、堆 等

    *   实战例子
        1.  B+树一般用于文件索引，如：Mysql的索引实现
        2.  字典树，用于字符串多模式匹配
        3.  红黑树，用于搜索引擎

3.  图
    *   图的组成主要有：有向图、无向图、带权图
    *   一般场景，如：用于网络流量的动态规划、地理位置的路线分配等

### 二、算法

1.  排序算法

    *   要记住常用的排序，以及时间和空间复杂度。

    *   算法有：希尔、直插，冒泡、快排，简单排序、堆排，归并，基数

    *   常考的为：快排，堆排

2.  查找
    *   二分查找：常用于小数据量集的内存查找，如：IP地址对应的省份
    *   二叉排序树查找，和数据结构的树对应
    *   B树：常用于索引中
    *   Hash
    *   BloomFilter：常用于大数据量集中，判断对象是否存在

3.  常用算法思路
    *   分治
    *   归并规划
    *   贪心
    *   回溯
    *   分支界定

4.  算法复杂度
    *   时间和空间：主要是通过分析算法本身，了解到算法在空间和时间上的开销。

5.  字符串匹配
    *   BF算法
    *   BM算法
    *   Sunday算法
    *   KMP算法
    *   Tire算法

### 三、网络

计算机网络，是不同计算机之间沟通的一个介质，这些内容是最基础的，也是必须了解的部分。

1.  通讯协议
    *   TCP/ IP，要了解三次握手、四次挥手的过程，以及通过系统的一些命令去观察这部分的链接问题
    *   HTTP/HTTPS，还要包含 HTTP1.1 和 HTTP2.0，以及HTTPS在加密方面的过程
    *   RPC/Socket
    *   WebSocket
    *   RTP
    *   RESP
    *   AMQP

2.  DNS

    以一个问题来阐述：一次浏览器请求外部链接，中间发生的过程有哪些？

### 四、系统内核

系统内核涉及的知识点非常多，这里仅列出了几个比较常见的问题。

1.  Linux锁的方式
    *   自旋锁
    *   信号量：内核信号量和IPC信号量

2.  内核模式和用户模式

3.  如何申请内存
    *   vmalloc 大内存申请，线性地址连续，物理地址可能不连续
    *   kmalloc 小内存申请，线性地址和物理地址都连续

4.  用户进程的通讯方式

    *   管道（Pipe）：某个进程与他共有祖先的进程可进行通讯

    *   命名管道（Named Pipe）：主要是对管道本身进行了命名，具有管道的所有功能。mkfifo来启动，可用不同进程间的通讯。Erlang语言的内部多采用与此。

    *   信号（Single）

    *   消息队列（Message Queue）

    *   共享内存（Shared Memory）

    *   信号量（Semaphore）

    *   套接字（Socket）

### 五、数据库

数据库一般情况下分为，内存数据库和关系型数据库。以下用Redis和Mysql来作代表

1.  Redis

-   持久化的方式

-   -   AOF：

    -   -   按照一定时间间隔，将缓存的操作命令记录到文件中
        -   有一定的时间差，数据可能丢失比较多

    -   RDB

    -   -   save：阻塞当前进程，将内存备份到文件中
        -   bgsave：folk一个子进程，与主线程共享内存，把内存写入到文件中，再覆盖原有的文件

-   数据类型

-   -   字符串：有一定的内存大小限制
    -   Hash
    -   列表（List）
    -   集合（Set）
    -   有序集合（Zset）

-   过期策略

-   -   定期删除：每隔一段时间检查抽样
    -   惰性删除：在访问Key的时候检查，过期则删除

-   集群管理

-   -   主从设置与数据备份
    -   数据的分割和有效管理：一般会用到一致性Hash

2.  Mysql

这里没有分引擎来说

-   索引

-   -   B+树
    -   搜索树

-   数据量大的优化方向

-   -   SQL语句本身
    -   索引优化
    -   自带分库分表
    -   拆分集群的服务优化

-   事务

-   -   特性

    -   -   一致性
        -   原子性
        -   隔离性
        -   持久性

    -   隔离级别

    -   -   未提交读
        -   提交读
        -   可重复读
        -   串行读

### 六、架构

架构方面主要讲微服务的内容

1.  异步微服务

    如通过消息中间件，用于服务之间的沟通，达到服务本身没有耦合的状态

2.  同步微服务

    如通过注册发现机制，找到需要请求的服务对象，并从微服务A向B直接发起请求

3.  微服务主要要解决的几个问题

-   分布式事务

-   -   XA-协议（2PC）
    -   TCC，多用于电商和金融
    -   一致性协调，多用于消息队列的方式
    -   阿里云GTS

-   分布式链路管理：路由管理

-   分布式链路问题追踪

### 七、Golang本身

1.  CAP理论（分布式系统理论）
    *   一致性（Consistency）
    *   可用性（Availability）
    *   分区容错性（Partition tolerance）

2.  内存回收

    Golang在早期的版本是使用引用计数法，在1.4-1.7分别对引用计数改进，以及引入标记清除，再对标记清除做改进，到三色标记；在1.8以后引入分代回收。

    *   引用计数法：标记计数的次数频繁，导致性能下降。同时无法解决循环引用的问题。
    *   标记清除法：标记未引用的内存，在一定时间周期做消除。并发多的情况下，也会影响性能
    *   三色标记法
    *   分代回收法：相当于多个堆，按照不同等级划分

3.  GMP原理
    1.  Goroutine：Go携程管理里面最小的单位。启动Goroutine时，会自动放入一个Processor队列中，包含Main函数
    2.  Processor：协调Machine来执行自己队列中的Goroutine
    3.  Machine：可以理解为线程，所有Goroutine都在上面执行

4.  锁的方式
    1.  自旋锁：如sync包中的锁
    2.  互斥锁
    3.  CLHLocker：基于隐式链表，没有序节点属性
    4.  MCSLocker：基于显示链表，有序节点属性
    5.  CAS算法：当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试

5.  字符串的原理
    *   固定长度的Slice对象
    *   bytes.Buffer的操作原理
    *   Slice对象的内存分配问题

### 八、常用工具及操作命令

1.  命令行重点
    1.  top
    2.  lsof
    3.  netstat
    4.  iostat
    5.  free
    6.  ps
    7.  df / du
    8.  awk

2.  工程管理工具
    1.  github
    2.  gitlab
    3.  svn
