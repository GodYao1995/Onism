[TOC]

## 锁

> 当数据库有并发事务的时候，可能导致产生的数据不一致，这就需要锁机制来保障访问的次序

### 一致性读

MVCC并发版本控制，一致性非锁定读，或者称为快照读，可显著提醒并发性能, 不会对记录做加锁的操作，其他事务可自由修改记录

### 行锁

#### 锁定读

MVCC并不能解决写-写的并发事务问题，必须通过加锁的形式（行锁）

##### 共享锁: S 独占锁: X

> 互斥即是阻塞等待锁释放

1. S-S 兼容 
2. S-X 互斥  X-S互斥
3. X-X互斥

**注意：事务中采用的是两阶段锁协议, 当遇到第一个查询语句事务开启，遇到第一个修改语句加锁, 事务提交锁释放**

##### 锁定语句

1. 读加S锁：别的事务可以获取S锁来读取数据，阻塞写操作获取X锁，直到锁释放

~~~mysql
SELECT ... LOCK IN SHARE MODE;
~~~

2. 读加X锁：阻塞获取S锁、X锁的事务，直到锁释放

~~~mysql
SELECT ... FOR UPDATE;
~~~

#### 写操作

1. DELETE B+树中获取到该记录，然后获取X锁, 进行DELETE MARK(可以看成锁定读)
2. UPDATE
   * 未修改键值, 并且修改列存储空间不变；B+树定位记录，获取X锁，原地修改
   * 未修改键值，并且修改列的存储空间改变；B+树定位记录，获取X锁，删除该记录，新增一条记录
   * 修改键值；先DELETE操作，然后INSERT操作
3. INSERT 插入不加锁，通过隐式锁保证事务未提交之前不被其他事务读取到

### 行锁类型

#### Record Locks

> 即是前面所说的普通行锁

1. S
2. X

#### Gap Locks(间隙锁)

> 加锁(Gap Locks)的形式防止插入幻影行，防止往该记录前面的间隙插入记录(不包括记录本身)

#### Next-Key Locks

> 加锁的形式避免插入幻影行并且对记录加锁

1. Record Locks 加记录锁
2. Gap Locks 加间隙锁

#### 隐式锁

一个事务执行INSERT 操作，如果被插入的间隙有Gap锁，那么INSERT 就会阻塞等待，并且当前事务就会在该间隙加上插入意向锁。 但是普通情况下的INSERT是不加锁操作，所以就有可能在其他事物中发生脏读，脏写。但是由于事务id的存在，会判断该事务是不是活跃事务，如果是就会帮助当前事务加X锁，然后自己本身加锁，进入等待状态

### 多粒度锁

#### 表锁

> 表锁的粒度太粗，导致并发性能低，一般情况下不使用(在某些特殊情况下用到, 例如崩溃恢复)

1. 共享锁: S 
2. 独占锁: X

ALTER DROP 等DDL 语句，同时其他查询语句会被阻塞, 是在Server层的**元数据锁**实现,并非表锁

可以手动开启表锁

~~~mysql
LOCK TABLES t READ;
LOCK TABLES t WRITE;
~~~

#### 意向锁

> 为了在对表加S或者X锁之前快速判断记录是否被加了锁；意向锁之间是互相兼容的

1. 意向共享锁: IS
2. 意向独占锁: IX

#### AUTO-INC锁

> 自增主键，保证连续性

### 回头再看

#### 隔离级别和锁、MVCC的关系

1.  读未提交，不需要加共享锁
2.  读提交，读操作加共享锁，语句执行完成释放锁
3.  可重复读，读操作加共享锁，事务执行完成以后才释放共享锁
4.  可串行化，事务执行完成才释放锁

#### 分类

1.  行级锁 InnoDB，开销大，加锁慢，锁粒度小，发生锁冲突概率低，并发度高
2.  表锁 MyISAM，开销小，锁粒度大，发生锁冲突概率高，并发度低
3.  页级锁

InnoDB实现了三种锁，行锁的实现是基于索引的

从类别上看，分为共享锁，和排他锁

#### 死锁

多个事务在同一资源上相互占用，并且请求锁定对方资源

1.  如果并发存取多个表，尽量控制访问顺序
2.  同一个事务，尽量一次锁定所需要的资源
3.  业务处理不好可以使用分布式锁或者乐观锁

#### 乐观锁、悲观锁

1.  悲观锁，假定会发生并发冲突，屏蔽一切可能导致数据不完整的操作，采用数据库锁机制
2.  乐观锁，假定不会发生并发冲突，只是在提交的时候检查是否违背数据完整性。在修改的时候把事务锁起来，通过version版本机制实现。适用于写少的情况。