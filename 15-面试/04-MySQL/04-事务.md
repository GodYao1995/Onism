[TOC]

## 事务

### 数据库事务

1.  一组原子性的SQL,一个不可分割的数据库操作序列
3.  事务中命令全部执行成功, 要么全都不执行失败

### ACID

> 事务的四大特性

1.  原子性: 事务是最小的执行单位, 不允许分割, 确保动作全部执行或者全部不执行
2.  一致性: 事务执行的结果是数据库从一种一致性状态转变到另一种一致性状态
3.  隔离性: 一个事务所做的修改在最终提交以前，对其他事务是不可见的(与隔离级别有关)
4.  持久性：一个事务被提交后, 对数据库中的数据改变是持久的

### 事务状态

1. 活动
2. 部分提交(操作完成，但是并未刷新到磁盘)
3. 失败
4. 终止
5. 提交(操作完成，刷新到磁盘)

### 并发事务问题

1.  脏读
    * 一个事务读取到了另一个事务未提交的数据
    * A事务更新, B事务读取, 但是A由于某些原因回滚了, 导致B事务读取的数据不正确
2.  不可重复读：
    * 一个事务每次都是读取到另一个事物每次提交的最新数据
    * A事务查询，B事务更新数据，事务A中能读取B更新同一记录的最新值
3.  幻读
    * 一个事务中两次查询记录不一致, 两次查询之间其他事务插入了数据，读取到了之前没有查询到的数据
    * A事务条件范围查询，B事务插入数据，导致A事务同一条件查询下，得到了之前没有的数据

### 隔离级别

> 低级别的隔离，可以换得更高的并发性能，但是也会带来并发事务问题

1.  读未提交 READ UNCOMMITTED, 可能发生脏读、不可重复读、幻读
2.  读提交 READ COMMITTED, 可能发生不可重复读、幻读
3.  可重复读 REPEATABLE READ, 多次读取是一致的, 可能发生幻读(MySQL可以禁止幻读通过锁)
4.  可串行化 SERIALIZABLE, 最高隔离级别符合ACID特性,对读取的每一行加锁(所有事务依次执行)

### 解决并发事务问题

#### 方案1

##### 读：MVCC

> 只在 READ COMMITTED 与 REPEATABLE READ 起作用，目的是提高并发性能

**MySQL默认使用可重复读的隔离级别, 事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVVC(多版本并发控制), 通过保存修改的旧版本信息来支持并发一致性非锁定读(快照读)和回滚等特性**

版本链

> 事务对记录的更新会生成一个undo日志版本链，可重复读隔离级别下，需要判断版本链中那个版本是当前事务可见

ReadView

> READ COMMITTED 每次**普通查询**就会生成ReadView(读取最新已经提交的事务)
>
> REPEATABLE READ 只在第一次**普通查询**生成ReadView ，此后的查询都使用该View(避免不可重复读和幻读)

有了ReadView的概念，即可提高读-读, 读-写的并发性能(读历史版本数据，写最新的记录之间并不矛盾)

##### 写：加锁

写针对的是最新版本的数据,必须是事务提交后的记录(两阶段锁协议)

#### 方案2: 读写都加锁

> 具体见锁章

1. 读操作加锁
2. 写操作加锁