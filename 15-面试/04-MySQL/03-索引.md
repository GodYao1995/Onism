[TOC]

### 索引

#### 原理

##### B+树

##### 结论

1. 每个索引都对应一颗B+树, 叶子结点存储普通记录, 内结点存储目录项纪录
2. InnoDB引擎会自动为主键创建聚簇索引, 其叶子结点包含完整的用户记录(索引即记录)
3. 创建二级索引, 二级索引的叶子结点是二级索引列与主键值, 查完整记录需要回表
4. B+树每层结点是按照索引列从小到大的顺序排序组成双向链表, 每个页内的记录是按照索引列值从大到小的顺序组成单向链表. 如果是联合索引, 那么页面与记录按照联合索引的顺序, 依次排序
5. B+树的搜索是按照根结点开始.

#### 使用

##### 代价

1. 空间上, 每建立一个索引, 都需要建立一个B+树, 每个结点是一个大小为16K的数据页
2. 时间上, 修改记录, 都会修改B+树, 维护索引

##### 条件

> A B C D 四列, A B C 建立联合索引

ABC三列建立联合索引, 需要注意, 在索引B+树存储中, 先按照A排序, 如果A相同再按照B排序, 如果B相同则按照C排序

1. 全值匹配

~~~mysql
SELECT * FROM T WHERE A = 'Va' AND B = 'Vb' AND C = 'Vc'
~~~

全值匹配中WHERE子句的顺序是没有影响的, 查询优化器会分析优化； 联合索引三个列都可能被用到

2. 匹配左边的列

~~~mysql
SELECT * FROM T WHERE A = 'Va'						 -- 可用到 A
SELECT * FROM T WHERE A = 'Va'AND C = 'Vc' -- 可用到 A
SELECT * FROM T WHERE C = 'Vc'						 -- 不可用
~~~

由于联合索引的实现方式, A B C 排序，所以想使用到联合索引的列, 搜索条件就必须联合索引最左边连续的列

3. 匹配列前缀

~~~mysql
SELECT * FROM T WHERE A like 'Mar%'
~~~

字符串列的排序也是按照每个字符排序的, 所以索引支持前缀

4. 匹配范围值

~~~mysql
SELECT * FROM T WHERE A > 'Va' AND A < 'Vz'
~~~

由于数据页与记录是按照A排序的, 页通过双向链表, 记录通过单向链表, 先找Va, 再找Vz, 然后取出即可

5. 精确匹配列并且范围匹配其他列

~~~mysql
SELECT * FROM T WHERE A = 'Va' AND B > 'Vb' AND B < 'Vn' AND C < 'Vc'
~~~

由于A是精确匹配可以用到索引, 并且得到的结果A是相同的, 并且B也是按照顺序的，所以B也可用到索引, B得到的结果可能是范围值, 所以C无法使用到索引, 只能遍历上一步的结果

6. 排序

注意：排序的列的排序顺序必须是一致的, 同升同降

~~~mysql
SELECT * FROM T ORDER BY A, B, C 
~~~

使用联合索引排序的列也必须是联合索引的顺序；如果搜索的列是左侧列, 那么剩下的连续列也是可用索引的

~~~mysql
SELECT * FROM T WHERE A = 'Va' ORDER BY B, C
~~~

如果搜索的列是非排序使用到索引列, 那么排序依然使用不到索引

~~~mysql
SELECT * FROM T WHERE D = 'Vd' ORDER BY A, B -- 不可使用到索引
~~~

如果排序的列包含一个非同一个索引列，那么排序久无法使用到索引

~~~mysql
SELECT * FROM T ORDER BY A, D -- D 不可使用到索引
~~~

7. 分组

~~~mysql
SELECT A,B,C COUNT(*) FROM T GROUP BY A,B,C
~~~

分组的列也必须是联合索引的列顺序一致
