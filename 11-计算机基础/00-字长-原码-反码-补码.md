[TOC]

### 计算机基础

#### 字长

> 「计算机领域」字表示自然的数据单位，一次性处理事务的固定长度。一个字的位数称为子长。16、32、64位

#### 机器数

> 1. 一个数在计算机中的二进制表示，叫做机器数
> 2. 机器数有符号位，最高位存储符号，正数0，负数1

~~~
[+3]0000 0011 == 3
[-3]1000 0011 == -3
~~~

注意：机器数的形式值不等于真值「带符号位的机器数的真正数值称为真值」

> 真值：符号位+数字的绝对值 就是真值

#### 原码、反码、补码

##### 原码

> 符号位+真值的绝对值

~~~
[+1]0000 00001 == 1
[-1]1000 00001 == -1
~~~

第一位是符号位不参与真值计算，所以八位二进制范围【-127 ～ 127】

##### 反码

> 1. 正数的反码是其本身
> 2. 负数的反码是原码的基础上，符号位不变，其余位取反

~~~
[+1]0000 0001 ——反码 => 0000 0001
[-1]1000 0001 ——反码 => 1111 1110
~~~

##### 补码

> 1. 正数的补码是其本身
> 2. 负数的补码是在原码的基础上，符号位不变，其余位取反，然后+1「也就是在反码的基础上+1」

~~~
[+1]0000 0001 ——补码 => 0000 0001
[-1]1000 0001 ——补码 => 1111 1111
~~~

##### 为什么需要三种表示？

> 1. 人脑对于反码与补码是无法得到真值的，需要转换为原码来计算
> 2. 计算机如果需要辨别符号位那么基础的电路设计将变得复杂，并且影响效率

所以，设计一种能让符号位也参与的方式，并且根据运算法则，减去一个正数等于加上一个负数，这样机器就只需要计算加法

> 二进制加法：满2进1

原码

~~~
1 - 1 = 1 + (-1) => [0000 0001] + [1000 0001] = [1000 0010] = -2   
~~~

显然使用原码带符号位参与运算无法计算

反码

~~~
1 - 1 = 1 + (-1) => [0000 0001] + [1000 0001] 原码
				 => [0000 0001] + [1111 1110] 反码
				 => [1111 1111]
				 => [1000 0000] 
				 => -0
~~~

用反码计算，真值部分是正确的，但是对于0这个问题上，会出现-0的形式，但是0带符号是无意义的，并且会出现如下情况

~~~
[1000 0000] = -0
[0000 0000] = +0
~~~

补码

~~~
1 - 1 = 1 + (-1) => [0000 0001] + [1000 0001] 原码
				 => [0000 0001] + [1111 1110] 反码
				 => [0000 0001] + [1111 1111] 补码
				 => [1 0000 0000]             补码 1 不在字长里面
				 => [0000 0000]               补码 
				 => [0000 0000]               原码
~~~

结论：使用补码可以计算真值、并且解决-0的问题

##### 例子

~~~
(-1) + (-127) => [1000 0001] + [1111 1111] 原码
			  => [1111 1111] + [1000 0001] 补码
			  => [1000 0000]               补码
~~~

发现-128的补码形式为, 所以-128是没有原码与反码表示的

~~~
[1000 0000]
~~~

总结 8位二进制使用原码表示范围【-127~+127】补码表示范围【-128～127】

#### 补充

##### 十进制转二进制

> 除2取余，逆序排列

~~~
 2 | 42 0
 2 | 21 1
 2 | 10 0
 2 | 5  1
 2 | 2  0
 2 | 1  1
   | 0  
~~~

小数转二进制

> 1. 采用"乘2取整，顺序排列"法, 直到小数部分为0
> 2. 如果小数的整数部分有大于0的整数时，将整数部分和小数部分先单独转为二进制，再合在一起就可以了

~~~
0.125 * 2 = 0.25  0
0.25  * 2 = 0.5   0
0.5   * 2 = 1.0   1  

=> 0.001
~~~

##### 二进制转十进制

> 1. 从右到左用二进制的每个数去乘以2的相应次方，小数点后则是从左往右
> 2. 正整数可以直接换算，负整数则需要先取反再换算

~~~
# 注意此时都是补码表示
[0000 1001] = 1*2^0 + 1*2^3 = 9
[1000 0001]原 = [1111 1111]补 = 减1[1111 1110] = 取反[0000 0001] = -1
~~~

#### 总结

> **计算机采用补码进行存储（表示）**

| 类型 |       正数        |                负数                |
| :--: | :---------------: | :--------------------------------: |
| 原码 | 符号位+真值绝对值 |         符号位+真值绝对值          |
| 反码 | 正数反码是其本身  | 原码基础上，符号位不变，其余位取反 |
| 补码 | 正数补码是其本身  |            反码基础上+1            |

